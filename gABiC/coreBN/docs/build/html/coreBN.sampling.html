<!DOCTYPE html>
<html class="writer-html5" lang="English/Python">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>coreBN.sampling package &mdash; gABi 00.00.01 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="coreBN.tests package" href="coreBN.tests.html" />
    <link rel="prev" title="coreBN.models package" href="coreBN.models.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            gABi
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">coreBN</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="coreBN.html">coreBN package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="coreBN.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="coreBN.CItests.html">coreBN.CItests package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.IO.html">coreBN.IO package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.base.html">coreBN.base package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.estimators.html">coreBN.estimators package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.extern.html">coreBN.extern package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.factors.html">coreBN.factors package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.independencies.html">coreBN.independencies package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.inference.html">coreBN.inference package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.metrics.html">coreBN.metrics package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.models.html">coreBN.models package</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">coreBN.sampling package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.tests.html">coreBN.tests package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.utils.html">coreBN.utils package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="coreBN.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="coreBN.html#module-coreBN.global_vars">coreBN.global_vars module</a></li>
<li class="toctree-l3"><a class="reference internal" href="coreBN.html#module-coreBN">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">gABi</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="modules.html">coreBN</a></li>
          <li class="breadcrumb-item"><a href="coreBN.html">coreBN package</a></li>
      <li class="breadcrumb-item active">coreBN.sampling package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/coreBN.sampling.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="corebn-sampling-package">
<h1>coreBN.sampling package<a class="headerlink" href="#corebn-sampling-package" title="Permalink to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</section>
<section id="module-coreBN.sampling.HMC">
<span id="corebn-sampling-hmc-module"></span><h2>coreBN.sampling.HMC module<a class="headerlink" href="#module-coreBN.sampling.HMC" title="Permalink to this heading"></a></h2>
<p>A collection of methods for sampling from continuous models in coreBN</p>
<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.HMC.HamiltonianMC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.HMC.</span></span><span class="sig-name descname"><span class="pre">HamiltonianMC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_pdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulate_dynamics=&lt;class</span> <span class="pre">'coreBN.sampling.base.LeapFrog'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/HMC.html#HamiltonianMC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.HMC.HamiltonianMC" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class for performing sampling using simple
Hamiltonian Monte Carlo</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>An instance coreBN.models</em>) -- Model from which sampling has to be done</p></li>
<li><p><strong>grad_log_pdf</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseGradLogPDF</em><em>, </em><em>defaults to None</em>) -- A class to find log and gradient of log distribution for a given assignment
If None, then will use model.get_gradient_log_pdf</p></li>
<li><p><strong>simulate_dynamics</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseSimulateHamiltonianDynamics</em>) -- A class to propose future values of momentum and position in time by simulating
Hamiltonian Dynamics</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">HamiltonianMC</span> <span class="k">as</span> <span class="n">HMC</span><span class="p">,</span> <span class="n">LeapFrog</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">HMC</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">simulate_dynamics</span><span class="o">=</span><span class="n">LeapFrog</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">initial_pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">trajectory_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;recarray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">rec.array([(1.0, 1.0), (-3.1861687131079086, 3.7940994520145654),</span>
<span class="go"> (-1.6920542547310844, 6.347410703806017), ...,</span>
<span class="go"> (-1.8093621120575312, 5.940860883943261),</span>
<span class="go"> (0.3933248026088032, 6.3853098838119235),</span>
<span class="go"> (-0.8654072934719572, 6.023803629334816)],</span>
<span class="go">          dtype=[(&#39;x&#39;, &#39;&lt;f8&#39;), (&#39;y&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">samples</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="go">array([[ 3.0352818 ,  0.71379304],</span>
<span class="go">       [ 0.71379304,  4.91776713]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">.</span><span class="n">accepted_proposals</span>
<span class="go">9932.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">.</span><span class="n">acceptance_rate</span>
<span class="go">0.9932</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>R.Neal. Handbook of Markov Chain Monte Carlo,
chapter 5: MCMC Using Hamiltonian Dynamics.
CRC Press, 2011.</p>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.HMC.HamiltonianMC.generate_sample">
<span class="sig-name descname"><span class="pre">generate_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajectory_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/HMC.html#HamiltonianMC.generate_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.HMC.HamiltonianMC.generate_sample" title="Permalink to this definition"></a></dt>
<dd><p>Method returns a generator type object whose each iteration yields a sample
using Hamiltonian Monte Carlo</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>trajectory_length</strong> (<em>int</em><em> or </em><em>float</em>) -- Target trajectory length, stepsize * number of steps(L),
where L is the number of steps taken per HMC iteration,
and stepsize is step size for splitting time method.</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be chosen suitably</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>genrator</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>yielding a 1d numpy.array type object for a sample</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">HamiltonianMC</span> <span class="k">as</span> <span class="n">HMC</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span> <span class="k">as</span> <span class="n">GLPG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">HMC</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GLPG</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen_samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">generate_sample</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">trajectory_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sample</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">gen_samples</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples_array</span>
<span class="go">array([[ 0.1467264 ,  0.27143857],</span>
<span class="go">       [ 4.0371448 ,  0.15871274],</span>
<span class="go">       [ 3.24656208, -1.03742621],</span>
<span class="go">       ...,</span>
<span class="go">       [ 6.45975905,  1.97941306],</span>
<span class="go">       [ 4.89007171,  0.15413156],</span>
<span class="go">       [ 5.9528083 ,  1.92983158]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">samples_array</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="go">array([[ 2.95692642,  0.4379419 ],</span>
<span class="go">       [ 0.4379419 ,  3.00939434]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">.</span><span class="n">acceptance_rate</span>
<span class="go">0.9969</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.HMC.HamiltonianMC.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajectory_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dataframe'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/HMC.html#HamiltonianMC.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.HMC.HamiltonianMC.sample" title="Permalink to this definition"></a></dt>
<dd><p>Method to return samples using Hamiltonian Monte Carlo</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>trajectory_length</strong> (<em>int</em><em> or </em><em>float</em>) -- Target trajectory length, stepsize * number of steps(L),
where L is the number of steps taken per HMC iteration,
and stepsize is step size for splitting time method.</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be chosen suitably</p></li>
<li><p><strong>return_type</strong> (<em>string</em><em> (</em><em>dataframe</em><em> | </em><em>recarray</em><em>)</em>) -- Return type for samples, either of 'dataframe' or 'recarray'.
Defaults to 'dataframe'</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A pandas.DataFrame or a numpy.recarray object depending upon return_type argument</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">HamiltonianMC</span> <span class="k">as</span> <span class="n">HMC</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">ModifiedEuler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">HMC</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">simulate_dynamics</span><span class="o">=</span><span class="n">ModifiedEuler</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">trajectory_length</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;dataframe&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">               x              y</span>
<span class="go">0   1.000000e+00   1.000000e+00</span>
<span class="go">1   1.592133e+00   1.152911e+00</span>
<span class="go">2   1.608700e+00   1.315349e+00</span>
<span class="go">3   1.608700e+00   1.315349e+00</span>
<span class="go">4   6.843856e-01   6.237043e-01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.7</span> <span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">HMC</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GLPG</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">trajectory_length</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;dataframe&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="go">array([[ 1.00795398,  0.71384233,  0.79802097],</span>
<span class="go">       [ 0.71384233,  1.00633524,  0.21313767],</span>
<span class="go">       [ 0.79802097,  0.21313767,  0.98519017]])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.HMC.HamiltonianMCDA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.HMC.</span></span><span class="sig-name descname"><span class="pre">HamiltonianMCDA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_pdf=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulate_dynamics=&lt;class</span> <span class="pre">'coreBN.sampling.base.LeapFrog'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta=0.65</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/HMC.html#HamiltonianMCDA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.HMC.HamiltonianMCDA" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#coreBN.sampling.HMC.HamiltonianMC" title="coreBN.sampling.HMC.HamiltonianMC"><code class="xref py py-class docutils literal notranslate"><span class="pre">HamiltonianMC</span></code></a></p>
<p>Class for performing sampling in Continuous model
using Hamiltonian Monte Carlo with dual averaging for
adaptaion of parameter stepsize.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>An instance coreBN.models</em>) -- Model from which sampling has to be done</p></li>
<li><p><strong>grad_log_pdf</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.GradientLogPDF</em>) -- Class to compute the log and gradient log of distribution</p></li>
<li><p><strong>simulate_dynamics</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseSimulateHamiltonianDynamics</em>) -- Class to propose future states of position and momentum in time by simulating
HamiltonianDynamics</p></li>
<li><p><strong>delta</strong> (<em>float</em><em> (</em><em>in between 0 and 1</em><em>)</em><em>, </em><em>defaults to 0.65</em>) -- The target HMC acceptance probability</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">HamiltonianMCDA</span> <span class="k">as</span> <span class="n">HMCda</span><span class="p">,</span> <span class="n">LeapFrog</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span> <span class="k">as</span> <span class="n">GLPG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">HMCda</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GLPG</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">num_adapt</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">trajectory_length</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;recarray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">samples</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">samples_array</span><span class="p">)</span>
<span class="go">array([[ 1.83023816,  0.40449162,  0.51200707],</span>
<span class="go">       [ 0.40449162,  2.85863596,  0.76747343],</span>
<span class="go">       [ 0.51200707,  0.76747343,  3.87020982]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">.</span><span class="n">acceptance_rate</span>
<span class="go">0.9929</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>Matthew D. Hoffman, Andrew Gelman, The No-U-Turn Sampler: Adaptively
Setting Path Lengths in Hamiltonian Monte Carlo. Journal of
Machine Learning Research 15 (2014) 1351-1381
Algorithm 5 : Hamiltonian Monte Carlo with dual averaging</p>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.HMC.HamiltonianMCDA.generate_sample">
<span class="sig-name descname"><span class="pre">generate_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_adapt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajectory_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/HMC.html#HamiltonianMCDA.generate_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.HMC.HamiltonianMCDA.generate_sample" title="Permalink to this definition"></a></dt>
<dd><p>Method returns a generator type object whose each iteration yields a sample
using Hamiltonian Monte Carlo</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_adapt</strong> (<em>int</em>) -- The number of iterations to run the adaptation of stepsize</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>trajectory_length</strong> (<em>int</em><em> or </em><em>float</em>) -- Target trajectory length, stepsize * number of steps(L),
where L is the number of steps taken to propose new values of position and momentum
per HMC iteration and stepsize is step size.</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be chosen suitably</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>genrator</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>yielding a numpy.array type object for a sample</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">HamiltonianMCDA</span> <span class="k">as</span> <span class="n">HMCda</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span> <span class="k">as</span> <span class="n">GLPG</span><span class="p">,</span> <span class="n">LeapFrog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">HMCda</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GLPG</span><span class="p">,</span> <span class="n">simulate_dynamics</span><span class="o">=</span><span class="n">LeapFrog</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen_samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">generate_sample</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_adapt</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">trajectory_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sample</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">gen_samples</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">samples_array</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="go">array([[ 0.98432155,  0.69517394],</span>
<span class="go">       [ 0.69517394,  2.95449533]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.HMC.HamiltonianMCDA.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_adapt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajectory_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dataframe'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/HMC.html#HamiltonianMCDA.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.HMC.HamiltonianMCDA.sample" title="Permalink to this definition"></a></dt>
<dd><p>Method to return samples using Hamiltonian Monte Carlo</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_adapt</strong> (<em>int</em>) -- The number of iterations to run the adaptation of stepsize</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>trajectory_length</strong> (<em>int</em><em> or </em><em>float</em>) -- Target trajectory length, stepsize * number of steps(L),
where L is the number of steps taken per HMC iteration,
and stepsize is step size for splitting time method.</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be chosen suitably</p></li>
<li><p><strong>return_type</strong> (<em>string</em><em> (</em><em>dataframe</em><em> | </em><em>recarray</em><em>)</em>) -- Return type for samples, either of 'dataframe' or 'recarray'.
Defaults to 'dataframe'</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A pandas.DataFrame or a numpy.recarray object depending upon return_type argument</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">HamiltonianMCDA</span> <span class="k">as</span> <span class="n">HMCda</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span> <span class="k">as</span> <span class="n">GLPG</span><span class="p">,</span> <span class="n">LeapFrog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">HMCda</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GLPG</span><span class="p">,</span> <span class="n">simulate_dynamics</span><span class="o">=</span><span class="n">LeapFrog</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_adapt</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">trajectory_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;recarray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">samples</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">samples_array</span><span class="p">)</span>
<span class="go">array([[ 0.98432155,  0.66517394],</span>
<span class="go">       [ 0.66517394,  2.95449533]])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="module-coreBN.sampling.NUTS">
<span id="corebn-sampling-nuts-module"></span><h2>coreBN.sampling.NUTS module<a class="headerlink" href="#module-coreBN.sampling.NUTS" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.NUTS.NoUTurnSampler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.NUTS.</span></span><span class="sig-name descname"><span class="pre">NoUTurnSampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_pdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulate_dynamics=&lt;class</span> <span class="pre">'coreBN.sampling.base.LeapFrog'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/NUTS.html#NoUTurnSampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.NUTS.NoUTurnSampler" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#coreBN.sampling.HMC.HamiltonianMCDA" title="coreBN.sampling.HMC.HamiltonianMCDA"><code class="xref py py-class docutils literal notranslate"><span class="pre">HamiltonianMCDA</span></code></a></p>
<p>Class for performing sampling in Continuous model
using No U Turn Sampler (a variant of Hamiltonian Monte Carlo)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>An instance coreBN.models</em>) -- Model from which sampling has to be done</p></li>
<li><p><strong>grad_log_pdf</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.GradientLogPDF</em>) -- Class to compute the log and gradient log of distribution</p></li>
<li><p><strong>simulate_dynamics</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseSimulateHamiltonianDynamics</em>) -- Class to propose future states of position and momentum in time by simulating
HamiltonianDynamics</p></li>
<li><p><strong>Methods</strong> (<em>Public</em>) -- </p></li>
<li><p><strong>--------------</strong> -- </p></li>
<li><p><strong>sample</strong><strong>(</strong><strong>)</strong> -- </p></li>
<li><p><strong>generate_sample</strong><strong>(</strong><strong>)</strong> -- </p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">NoUTurnSampler</span> <span class="k">as</span> <span class="n">NUTS</span><span class="p">,</span> <span class="n">LeapFrog</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">NUTS</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">simulate_dynamics</span><span class="o">=</span><span class="n">LeapFrog</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">initial_pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]),</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;recarray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">rec.array([(0.1, 0.9, 0.3),</span>
<span class="go"> (-0.27303886844752756, 0.5028580705249155, 0.2895768065049909),</span>
<span class="go"> (1.7139810571103862, 2.809135711303245, 5.690811523613858), ...,</span>
<span class="go"> (-0.7742669710786649, 2.092867703984895, 6.139480724333439),</span>
<span class="go"> (1.3916152816323692, 1.394952482021687, 3.446906546649354),</span>
<span class="go"> (-0.2726336476939125, 2.6230854954595357, 2.923948403903159)],</span>
<span class="go">          dtype=[(&#39;x&#39;, &#39;&lt;f8&#39;), (&#39;y&#39;, &#39;&lt;f8&#39;), (&#39;z&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>Matthew D. Hoffman, Andrew Gelman, The No-U-Turn Sampler: Adaptively
Setting Path Lengths in Hamiltonian Monte Carlo. Journal of
Machine Learning Research 15 (2014) 1351-1381
Algorithm 3 : Efficient No-U-Turn Sampler</p>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.NUTS.NoUTurnSampler.generate_sample">
<span class="sig-name descname"><span class="pre">generate_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/NUTS.html#NoUTurnSampler.generate_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.NUTS.NoUTurnSampler.generate_sample" title="Permalink to this definition"></a></dt>
<dd><p>Returns a generator type object whose each iteration yields a sample</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be chosen suitably</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>generator</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>yielding a numpy.array type object for a sample</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">NoUTurnSampler</span> <span class="k">as</span> <span class="n">NUTS</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">14</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">NUTS</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GradLogPDFGaussian</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">generate_sample</span><span class="p">(</span><span class="n">initial_pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sample</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">array([[ 10.26357538,   0.10062725],</span>
<span class="go">       [ 12.70600336,   0.63392499],</span>
<span class="go">       [ 10.95523217,  -0.62079273],</span>
<span class="go">       [ 10.66263031,  -4.08135962],</span>
<span class="go">       [ 10.59255762,  -8.48085076],</span>
<span class="go">       [  9.99860242,  -9.47096032],</span>
<span class="go">       [ 10.5733564 ,  -9.83504745],</span>
<span class="go">       [ 11.51302059,  -9.49919523],</span>
<span class="go">       [ 11.31892143,  -8.5873259 ],</span>
<span class="go">       [ 11.29008667,  -0.43809674]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.NUTS.NoUTurnSampler.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dataframe'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/NUTS.html#NoUTurnSampler.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.NUTS.NoUTurnSampler.sample" title="Permalink to this definition"></a></dt>
<dd><p>Method to return samples using No U Turn Sampler</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be choosen suitably</p></li>
<li><p><strong>return_type</strong> (<em>string</em><em> (</em><em>dataframe</em><em> | </em><em>recarray</em><em>)</em>) -- Return type for samples, either of 'dataframe' or 'recarray'.
Defaults to 'dataframe'</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A pandas.DataFrame or a numpy.recarray object depending upon return_type argument</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">NoUTurnSampler</span> <span class="k">as</span> <span class="n">NUTS</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">LeapFrog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">6</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">NUTS</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">simulate_dynamics</span><span class="o">=</span><span class="n">LeapFrog</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">initial_pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;dataframe&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">          x         y         z</span>
<span class="go">0  1.000000  1.000000  1.000000</span>
<span class="go">1  1.760756  0.271543 -0.613309</span>
<span class="go">2  1.883387  0.990745 -0.611720</span>
<span class="go">3  0.980812  0.340336 -0.916283</span>
<span class="go">4  0.781338  0.647220 -0.948640</span>
<span class="go">5  0.040308 -1.391406  0.412201</span>
<span class="go">6  1.179549 -1.450552  1.105216</span>
<span class="go">7  1.100320 -1.313926  1.207815</span>
<span class="go">8  1.484520 -1.349247  0.768599</span>
<span class="go">9  0.934942 -1.894589  0.471772</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.NUTS.NoUTurnSamplerDA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.NUTS.</span></span><span class="sig-name descname"><span class="pre">NoUTurnSamplerDA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_pdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulate_dynamics=&lt;class</span> <span class="pre">'coreBN.sampling.base.LeapFrog'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta=0.65</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/NUTS.html#NoUTurnSamplerDA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.NUTS.NoUTurnSamplerDA" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#coreBN.sampling.NUTS.NoUTurnSampler" title="coreBN.sampling.NUTS.NoUTurnSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">NoUTurnSampler</span></code></a></p>
<p>Class for performing sampling in Continuous model
using No U Turn sampler with dual averaging for
adaptation of parameter stepsize.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>An instance coreBN.models</em>) -- Model from which sampling has to be done</p></li>
<li><p><strong>grad_log_pdf</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.GradientLogPDF</em>) -- Class to compute the log and gradient log of distribution</p></li>
<li><p><strong>simulate_dynamics</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseSimulateHamiltonianDynamics</em>) -- Class to propose future states of position and momentum in time by simulating
HamiltonianDynamics</p></li>
<li><p><strong>delta</strong> (<em>float</em><em> (</em><em>in between 0 and 1</em><em>)</em><em>, </em><em>defaults to 0.65</em>) -- The target HMC acceptance probability</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">NoUTurnSamplerDA</span> <span class="k">as</span> <span class="n">NUTSda</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">NUTSda</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GradLogPDFGaussian</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">initial_pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">num_adapt</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;recarray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">rec.array([(0.0, 0.0, 0.0),</span>
<span class="go"> (0.06100992691638076, -0.17118088764170125, 0.14048470935160887),</span>
<span class="go"> (0.06100992691638076, -0.17118088764170125, 0.14048470935160887),</span>
<span class="go"> (-0.7451883138013118, 1.7975387358691155, 2.3090698721374436),</span>
<span class="go"> (-0.6207457594500309, 1.4611049498441024, 2.5890867012835574),</span>
<span class="go"> (0.24043604780911487, 1.8660976216530618, 3.2508715592645347),</span>
<span class="go"> (0.21509819341468212, 2.157760225367607, 3.5749582768731476),</span>
<span class="go"> (0.20699150582681913, 2.0605044285377305, 3.8588980251618135),</span>
<span class="go"> (0.20699150582681913, 2.0605044285377305, 3.8588980251618135),</span>
<span class="go"> (0.085332419611991, 1.7556171374575567, 4.49985082288814)],</span>
<span class="go">          dtype=[(&#39;x&#39;, &#39;&lt;f8&#39;), (&#39;v&#39;, &#39;&lt;f8&#39;), (&#39;t&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>Matthew D. Hoffman, Andrew Gelman, The No-U-Turn Sampler: Adaptively
Setting Path Lengths in Hamiltonian Monte Carlo. Journal of
Machine Learning Research 15 (2014) 1351-1381
Algorithm 6 : No-U-Turn Sampler with Dual Averaging</p>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.NUTS.NoUTurnSamplerDA.generate_sample">
<span class="sig-name descname"><span class="pre">generate_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_adapt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/NUTS.html#NoUTurnSamplerDA.generate_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.NUTS.NoUTurnSamplerDA.generate_sample" title="Permalink to this definition"></a></dt>
<dd><p>Returns a generator type object whose each iteration yields a sample</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_adapt</strong> (<em>int</em>) -- The number of iterations to run the adaptation of stepsize</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be chosen suitably</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>generator</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>yielding a numpy.array type object for a sample</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.NUTS.NoUTurnSamplerDA.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_adapt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dataframe'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/NUTS.html#NoUTurnSamplerDA.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.NUTS.NoUTurnSamplerDA.sample" title="Permalink to this definition"></a></dt>
<dd><p>Returns samples using No U Turn Sampler with dual averaging</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_adapt</strong> (<em>int</em>) -- The number of iterations to run the adaptation of stepsize</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be chosen suitably</p></li>
<li><p><strong>return_type</strong> (<em>string</em><em> (</em><em>dataframe</em><em> | </em><em>recarray</em><em>)</em>) -- Return type for samples, either of 'dataframe' or 'recarray'.
Defaults to 'dataframe'</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A pandas.DataFrame or a numpy.recarray object depending upon return_type argument</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">NoUTurnSamplerDA</span> <span class="k">as</span> <span class="n">NUTSda</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">LeapFrog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">13</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">NUTSda</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">simulate_dynamics</span><span class="o">=</span><span class="n">LeapFrog</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">initial_pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]),</span> <span class="n">num_adapt</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;dataframe&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">           x          y</span>
<span class="go">0  12.000000  -4.000000</span>
<span class="go">1  11.864821  -3.696109</span>
<span class="go">2  10.546986  -4.892169</span>
<span class="go">3   8.526596 -21.555793</span>
<span class="go">4   8.526596 -21.555793</span>
<span class="go">5  11.343194  -6.353789</span>
<span class="go">6  -1.583269 -12.802931</span>
<span class="go">7  12.411957 -11.704859</span>
<span class="go">8  13.253336 -20.169492</span>
<span class="go">9  11.295901  -7.665058</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="module-coreBN.sampling.Sampling">
<span id="corebn-sampling-sampling-module"></span><h2>coreBN.sampling.Sampling module<a class="headerlink" href="#module-coreBN.sampling.Sampling" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.Sampling.BayesianModelSampling">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.Sampling.</span></span><span class="sig-name descname"><span class="pre">BayesianModelSampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/Sampling.html#BayesianModelSampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.Sampling.BayesianModelSampling" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#coreBN.sampling.base.BayesianModelInference" title="coreBN.sampling.base.BayesianModelInference"><code class="xref py py-class docutils literal notranslate"><span class="pre">BayesianModelInference</span></code></a></p>
<p>Class for sampling methods specific to Bayesian Models</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>model</strong> (<em>instance</em><em> of </em><a class="reference internal" href="coreBN.models.html#coreBN.models.BayesianNetwork" title="coreBN.models.BayesianNetwork"><em>BayesianNetwork</em></a>) -- model on which inference queries will be computed</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.Sampling.BayesianModelSampling.forward_sample">
<span class="sig-name descname"><span class="pre">forward_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partial_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/Sampling.html#BayesianModelSampling.forward_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.Sampling.BayesianModelSampling.forward_sample" title="Permalink to this definition"></a></dt>
<dd><p>Generates sample(s) from joint distribution of the bayesian network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) -- size of sample to be generated</p></li>
<li><p><strong>include_latents</strong> (<em>boolean</em>) -- Whether to include the latent variable values in the generated samples.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> (</em><em>default: None</em><em>)</em>) -- If a value is provided, sets the seed for numpy.random.</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) -- Whether to show a progress bar of samples getting generated.</p></li>
<li><p><strong>partial_samples</strong> (<em>pandas.DataFrame</em>) -- A pandas dataframe specifying samples on some of the variables in the model. If
specified, the sampling procedure uses these sample values, instead of generating them.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong> -- The generated samples</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.models</span> <span class="kn">import</span> <span class="n">BayesianNetwork</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">TabularCPD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">BayesianModelSampling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">BayesianNetwork</span><span class="p">([(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_d</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_i</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_g</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;grade&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span>
<span class="gp">... </span>               <span class="mf">0.08</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;diff&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_cpds</span><span class="p">(</span><span class="n">cpd_d</span><span class="p">,</span> <span class="n">cpd_i</span><span class="p">,</span> <span class="n">cpd_g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inference</span> <span class="o">=</span> <span class="n">BayesianModelSampling</span><span class="p">(</span><span class="n">student</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inference</span><span class="o">.</span><span class="n">forward_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">rec.array([(0, 0, 1), (1, 0, 2)], dtype=</span>
<span class="go">          [(&#39;diff&#39;, &#39;&lt;i8&#39;), (&#39;intel&#39;, &#39;&lt;i8&#39;), (&#39;grade&#39;, &#39;&lt;i8&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.Sampling.BayesianModelSampling.likelihood_weighted_sample">
<span class="sig-name descname"><span class="pre">likelihood_weighted_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evidence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/Sampling.html#BayesianModelSampling.likelihood_weighted_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.Sampling.BayesianModelSampling.likelihood_weighted_sample" title="Permalink to this definition"></a></dt>
<dd><p>Generates weighted sample(s) from joint distribution of the bayesian
network, that comply with the given evidence.
'Probabilistic Graphical Model Principles and Techniques', Koller and
Friedman, Algorithm 12.2 pp 493.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>evidence</strong> (list of <cite>core.factor.State</cite> namedtuples) -- None if no evidence</p></li>
<li><p><strong>size</strong> (<em>int</em>) -- size of sample to be generated</p></li>
<li><p><strong>include_latents</strong> (<em>boolean</em>) -- Whether to include the latent variable values in the generated samples.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> (</em><em>default: None</em><em>)</em>) -- If a value is provided, sets the seed for numpy.random.</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) -- Whether to show a progress bar of samples getting generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong> -- The generated samples with corresponding weights</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A pandas.DataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">State</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.models</span> <span class="kn">import</span> <span class="n">BayesianNetwork</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">TabularCPD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">BayesianModelSampling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">BayesianNetwork</span><span class="p">([(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_d</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_i</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_g</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;grade&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span>
<span class="gp">... </span>        <span class="mf">0.08</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]],</span>
<span class="gp">... </span>        <span class="p">[</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;diff&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_cpds</span><span class="p">(</span><span class="n">cpd_d</span><span class="p">,</span> <span class="n">cpd_i</span><span class="p">,</span> <span class="n">cpd_g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inference</span> <span class="o">=</span> <span class="n">BayesianModelSampling</span><span class="p">(</span><span class="n">student</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evidence</span> <span class="o">=</span> <span class="p">[</span><span class="n">State</span><span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inference</span><span class="o">.</span><span class="n">likelihood_weighted_sample</span><span class="p">(</span><span class="n">evidence</span><span class="o">=</span><span class="n">evidence</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;recarray&#39;</span><span class="p">)</span>
<span class="go">rec.array([(0, 0, 1, 0.6), (0, 0, 2, 0.6)], dtype=</span>
<span class="go">          [(&#39;diff&#39;, &#39;&lt;i8&#39;), (&#39;intel&#39;, &#39;&lt;i8&#39;), (&#39;grade&#39;, &#39;&lt;i8&#39;), (&#39;_weight&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.Sampling.BayesianModelSampling.rejection_sample">
<span class="sig-name descname"><span class="pre">rejection_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evidence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partial_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/Sampling.html#BayesianModelSampling.rejection_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.Sampling.BayesianModelSampling.rejection_sample" title="Permalink to this definition"></a></dt>
<dd><p>Generates sample(s) from joint distribution of the bayesian network,
given the evidence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>evidence</strong> (list of <cite>core.factor.State</cite> namedtuples) -- None if no evidence</p></li>
<li><p><strong>size</strong> (<em>int</em>) -- size of sample to be generated</p></li>
<li><p><strong>include_latents</strong> (<em>boolean</em>) -- Whether to include the latent variable values in the generated samples.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> (</em><em>default: None</em><em>)</em>) -- If a value is provided, sets the seed for numpy.random.</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) -- Whether to show a progress bar of samples getting generated.</p></li>
<li><p><strong>partial_samples</strong> (<em>pandas.DataFrame</em>) -- A pandas dataframe specifying samples on some of the variables in the model. If
specified, the sampling procedure uses these sample values, instead of generating them.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong> -- The generated samples</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.models</span> <span class="kn">import</span> <span class="n">BayesianNetwork</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">TabularCPD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">State</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">BayesianModelSampling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">BayesianNetwork</span><span class="p">([(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_d</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_i</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_g</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;grade&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span>
<span class="gp">... </span>               <span class="mf">0.08</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;diff&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_cpds</span><span class="p">(</span><span class="n">cpd_d</span><span class="p">,</span> <span class="n">cpd_i</span><span class="p">,</span> <span class="n">cpd_g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inference</span> <span class="o">=</span> <span class="n">BayesianModelSampling</span><span class="p">(</span><span class="n">student</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evidence</span> <span class="o">=</span> <span class="p">[</span><span class="n">State</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inference</span><span class="o">.</span><span class="n">rejection_sample</span><span class="p">(</span><span class="n">evidence</span><span class="o">=</span><span class="n">evidence</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;dataframe&#39;</span><span class="p">)</span>
<span class="go">        intel       diff       grade</span>
<span class="go">0         0          0          1</span>
<span class="go">1         0          0          1</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.Sampling.GibbsSampling">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.Sampling.</span></span><span class="sig-name descname"><span class="pre">GibbsSampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/Sampling.html#GibbsSampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.Sampling.GibbsSampling" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="coreBN.models.html#coreBN.models.MarkovChain.MarkovChain" title="coreBN.models.MarkovChain.MarkovChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">MarkovChain</span></code></a></p>
<p>Class for performing Gibbs sampling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>model</strong> (<a class="reference internal" href="coreBN.models.html#coreBN.models.BayesianNetwork" title="coreBN.models.BayesianNetwork"><em>BayesianNetwork</em></a><em> or </em><a class="reference internal" href="coreBN.models.html#coreBN.models.MarkovNetwork" title="coreBN.models.MarkovNetwork"><em>MarkovNetwork</em></a>) -- Model from which variables are inherited and transition probabilities computed.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Initialization from a BayesianNetwork object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">TabularCPD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.models</span> <span class="kn">import</span> <span class="n">BayesianNetwork</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intel_cpd</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sat_cpd</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;sat&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">]],</span> <span class="n">evidence</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;intel&#39;</span><span class="p">],</span> <span class="n">evidence_card</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">BayesianNetwork</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;sat&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;sat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_cpds</span><span class="p">(</span><span class="n">intel_cpd</span><span class="p">,</span> <span class="n">sat_cpd</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">GibbsSampling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gibbs_chain</span> <span class="o">=</span> <span class="n">GibbsSampling</span><span class="p">(</span><span class="n">student</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gibbs_chain</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">   intel  sat</span>
<span class="go">0      0    0</span>
<span class="go">1      0    0</span>
<span class="go">2      1    1</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.Sampling.GibbsSampling.generate_sample">
<span class="sig-name descname"><span class="pre">generate_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/Sampling.html#GibbsSampling.generate_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.Sampling.GibbsSampling.generate_sample" title="Permalink to this definition"></a></dt>
<dd><p>Generator version of self.sample</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of State namedtuples, representing the assignment to all variables of the model.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">DiscreteFactor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">GibbsSampling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.models</span> <span class="kn">import</span> <span class="n">MarkovNetwork</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">MarkovNetwork</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_ab</span> <span class="o">=</span> <span class="n">DiscreteFactor</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_cb</span> <span class="o">=</span> <span class="n">DiscreteFactor</span><span class="p">([</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">add_factors</span><span class="p">(</span><span class="n">factor_ab</span><span class="p">,</span> <span class="n">factor_cb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gibbs</span> <span class="o">=</span> <span class="n">GibbsSampling</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">gibbs</span><span class="o">.</span><span class="n">generate_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">sample</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">]</span>
<span class="go">[[State(var=&#39;C&#39;, state=1), State(var=&#39;B&#39;, state=1), State(var=&#39;A&#39;, state=0)],</span>
<span class="go"> [State(var=&#39;C&#39;, state=0), State(var=&#39;B&#39;, state=1), State(var=&#39;A&#39;, state=1)]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.Sampling.GibbsSampling.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/Sampling.html#GibbsSampling.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.Sampling.GibbsSampling.sample" title="Permalink to this definition"></a></dt>
<dd><p>Sample from the Markov Chain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_state</strong> (<em>dict</em><em> or </em><em>array-like iterable</em>) -- Representing the starting states of the variables. If None is passed, a random start_state is chosen.</p></li>
<li><p><strong>size</strong> (<em>int</em>) -- Number of samples to be generated.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> (</em><em>default: None</em><em>)</em>) -- If a value is provided, sets the seed for numpy.random.</p></li>
<li><p><strong>include_latents</strong> (<em>boolean</em>) -- Whether to include the latent variable values in the generated samples.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong> -- The generated samples</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">DiscreteFactor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">GibbsSampling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.models</span> <span class="kn">import</span> <span class="n">MarkovNetwork</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">MarkovNetwork</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_ab</span> <span class="o">=</span> <span class="n">DiscreteFactor</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_cb</span> <span class="o">=</span> <span class="n">DiscreteFactor</span><span class="p">([</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">add_factors</span><span class="p">(</span><span class="n">factor_ab</span><span class="p">,</span> <span class="n">factor_cb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gibbs</span> <span class="o">=</span> <span class="n">GibbsSampling</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gibbs</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">return_tupe</span><span class="o">=</span><span class="s1">&#39;dataframe&#39;</span><span class="p">)</span>
<span class="go">   A  B  C</span>
<span class="go">0  0  1  1</span>
<span class="go">1  1  0  0</span>
<span class="go">2  1  1  0</span>
<span class="go">3  1  1  1</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.Sampling.State">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.Sampling.</span></span><span class="sig-name descname"><span class="pre">State</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#coreBN.sampling.Sampling.State" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="coreBN.sampling.Sampling.State.state">
<span class="sig-name descname"><span class="pre">state</span></span><a class="headerlink" href="#coreBN.sampling.Sampling.State.state" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="coreBN.sampling.Sampling.State.var">
<span class="sig-name descname"><span class="pre">var</span></span><a class="headerlink" href="#coreBN.sampling.Sampling.State.var" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-coreBN.sampling.base">
<span id="corebn-sampling-base-module"></span><h2>coreBN.sampling.base module<a class="headerlink" href="#module-coreBN.sampling.base" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.base.BaseGradLogPDF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.base.</span></span><span class="sig-name descname"><span class="pre">BaseGradLogPDF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable_assignments</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#BaseGradLogPDF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.base.BaseGradLogPDF" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for evaluating gradient log of probability density function/ distribution</p>
<p>Classes inheriting this base class can be passed as an argument for
finding gradient log of probability distribution in inference algorithms</p>
<p>The class should initialize  self.grad_log and self.log_pdf</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variable_assignments</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing values(assignments) of variables at which we want to find gradient and log</p></li>
<li><p><strong>model</strong> (<em>An instance</em><em> of </em><em>coreBN.models</em>) -- </p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.inference.continuous</span> <span class="kn">import</span> <span class="n">BaseGradLogPDF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">GradLogGaussian</span><span class="p">(</span><span class="n">BaseGradLogPDF</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">BaseGradLogPDF</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">grad_log</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gradient_log_pdf</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_get_gradient_log_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">sub_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mean</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="gp">... </span>        <span class="n">grad</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">precision_matrix</span><span class="p">,</span> <span class="n">sub_vec</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">log_pdf</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sub_vec</span><span class="p">,</span> <span class="n">grad</span><span class="p">))</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">grad</span><span class="p">,</span> <span class="n">log_pdf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grad_logp</span><span class="p">,</span> <span class="n">logp</span> <span class="o">=</span> <span class="n">GradLogGaussian</span><span class="p">(</span><span class="n">dist_param</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">get_gradient_log_pdf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logp</span>
<span class="go">-0.4054597701149426</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grad_logp</span>
<span class="go">array([ 0.90229885, -0.01149425])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.base.BaseGradLogPDF.get_gradient_log_pdf">
<span class="sig-name descname"><span class="pre">get_gradient_log_pdf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#BaseGradLogPDF.get_gradient_log_pdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.base.BaseGradLogPDF.get_gradient_log_pdf" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gradient log and log of model at given position</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>Returns a tuple of following types</em></p></li>
<li><p><strong>numpy.array</strong> (<em>Representing gradient log of model at given position</em>)</p></li>
<li><p><strong>float</strong> (<em>Representing log of model at given position</em>)</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Using implementation of GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling.base</span> <span class="kn">import</span> <span class="n">GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grad_logp</span><span class="p">,</span> <span class="n">logp</span> <span class="o">=</span> <span class="n">GradLogPDFGaussian</span><span class="p">(</span><span class="n">dist_param</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">get_gradient_log_pdf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logp</span>
<span class="go">0.025217391304347823</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grad_logp</span>
<span class="go">array([-0.07826087, -0.09565217])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.base.BaseSimulateHamiltonianDynamics">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.base.</span></span><span class="sig-name descname"><span class="pre">BaseSimulateHamiltonianDynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">momentum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_pdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#BaseSimulateHamiltonianDynamics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.base.BaseSimulateHamiltonianDynamics" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for proposing new values of position and momentum by simulating Hamiltonian Dynamics.</p>
<p>Classes inheriting this base class can be passed as an argument for
simulate_dynamics in inference algorithms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>An instance</em><em> of </em><em>coreBN.models</em>) -- Model for which DiscretizeTime object is initialized</p></li>
<li><p><strong>position</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing values of parameter position( or X)</p></li>
<li><p><strong>momentum</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing the proposed value for momentum (velocity)</p></li>
<li><p><strong>stepsize</strong> (<em>Float</em>) -- stepsize for the simulating dynamics</p></li>
<li><p><strong>grad_log_pdf</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseGradLogPDF</em>) -- A class for finding gradient log and log of distribution</p></li>
<li><p><strong>grad_log_position</strong> (<em>A 1d array like object</em><em>, </em><em>defaults to None</em>) -- Vector representing gradient log at given position
If None, then will be calculated</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">BaseSimulateHamiltonianDynamics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Class should initalize self.new_position, self.new_momentum and self.new_grad_logp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># self.new_grad_logp represents gradient log at new proposed value of position</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ModifiedEuler</span><span class="p">(</span><span class="n">BaseSimulateHamiltonianDynamics</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="n">stepsize</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="p">,</span> <span class="n">grad_log_position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">BaseSimulateHamiltonianDynamics</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">stepsize</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="p">,</span> <span class="n">grad_log_position</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">new_position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_momentum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_grad_logp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_proposed_values</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_get_proposed_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">momentum_bar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">momentum</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepsize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_log_position</span>
<span class="gp">... </span>        <span class="n">position_bar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepsize</span> <span class="o">*</span> <span class="n">momentum_bar</span>
<span class="gp">... </span>        <span class="n">grad_log_position</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_log_pdf</span><span class="p">(</span><span class="n">position_bar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">get_gradient_log_pdf</span><span class="p">()</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">position_bar</span><span class="p">,</span> <span class="n">momentum_bar</span><span class="p">,</span> <span class="n">grad_log_position</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">momentum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span><span class="p">,</span> <span class="n">new_momentum</span><span class="p">,</span> <span class="n">new_grad</span> <span class="o">=</span> <span class="n">ModifiedEuler</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span>
<span class="gp">... </span>                                                <span class="mf">0.25</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span><span class="p">)</span><span class="o">.</span><span class="n">get_proposed_values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span>
<span class="go">array([0.9375, 1.875])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_momentum</span>
<span class="go">array([-0.25, -0.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_grad</span>
<span class="go">array([-0.9375, -1.875])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.base.BaseSimulateHamiltonianDynamics.get_proposed_values">
<span class="sig-name descname"><span class="pre">get_proposed_values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#BaseSimulateHamiltonianDynamics.get_proposed_values"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.base.BaseSimulateHamiltonianDynamics.get_proposed_values" title="Permalink to this definition"></a></dt>
<dd><p>Returns the new proposed values of position and momentum</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>Returns a tuple of following type (in order)</em></p></li>
<li><p><strong>numpy.array</strong> (<em>A 1d numpy.array representing new proposed value of position</em>)</p></li>
<li><p><strong>numpy.array</strong> (<em>A 1d numpy.array representing new proposed value of momentum</em>)</p></li>
<li><p><strong>numpy.array</strong> (<em>A 1d numpy.array representing gradient of log distribution at new proposed value of position</em>)</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Using implementation of ModifiedEuler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.inference.continuous</span> <span class="kn">import</span> <span class="n">ModifiedEuler</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span> <span class="k">as</span> <span class="n">GLPG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">momentum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span><span class="p">,</span> <span class="n">new_momentum</span><span class="p">,</span> <span class="n">new_grad</span> <span class="o">=</span> <span class="n">ModifiedEuler</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="mf">0.70</span><span class="p">,</span> <span class="n">GLPG</span><span class="p">)</span><span class="o">.</span><span class="n">get_proposed_values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span>
<span class="go">array([ 3.04666667,  4.21      ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_momentum</span>
<span class="go">array([ 0.06666667,  0.3       ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_grad</span>
<span class="go">array([-1.34888889, -1.07      ])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.base.BayesianModelInference">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.base.</span></span><span class="sig-name descname"><span class="pre">BayesianModelInference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#BayesianModelInference"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.base.BayesianModelInference" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="coreBN.inference.html#coreBN.inference.base.Inference" title="coreBN.inference.base.Inference"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inference</span></code></a></p>
<p>Inference class specific to Bayesian Models</p>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.base.BayesianModelInference.pre_compute_reduce">
<span class="sig-name descname"><span class="pre">pre_compute_reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#BayesianModelInference.pre_compute_reduce"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.base.BayesianModelInference.pre_compute_reduce" title="Permalink to this definition"></a></dt>
<dd><p>Get probability arrays for a node as function of conditional dependencies</p>
<p>Internal function used for Bayesian networks, eg. in BayesianModelSampling
and BayesianModelProbability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>variable</strong> (<em>Bayesian Model Node</em>) -- node of the Bayesian network</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dict</strong> -- as function of conditional dependency values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary with probability array for node</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.base.BayesianModelInference.pre_compute_reduce_maps">
<span class="sig-name descname"><span class="pre">pre_compute_reduce_maps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#BayesianModelInference.pre_compute_reduce_maps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.base.BayesianModelInference.pre_compute_reduce_maps" title="Permalink to this definition"></a></dt>
<dd><p>Get probability array-maps for a node as function of conditional dependencies</p>
<p>Internal function used for Bayesian networks, eg. in BayesianModelSampling
and BayesianModelProbability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>variable</strong> (<em>Bayesian Model Node</em>) -- node of the Bayesian network</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dict</strong> -- dictionary with mapping of probability array-index to probability array.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary with probability array-index for node as function of conditional dependency values,</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.base.GradLogPDFGaussian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.base.</span></span><span class="sig-name descname"><span class="pre">GradLogPDFGaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable_assignments</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#GradLogPDFGaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.base.GradLogPDFGaussian" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#coreBN.sampling.base.BaseGradLogPDF" title="coreBN.sampling.base.BaseGradLogPDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseGradLogPDF</span></code></a></p>
<p>Class for finding gradient and gradient log of Joint Gaussian Distribution
Inherits coreBN.inference.base_continuous.BaseGradLogPDF
Here model must be an instance of GaussianDistribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variable_assignments</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing values of variables at which we want to find gradient and log</p></li>
<li><p><strong>model</strong> (<em>An instance</em><em> of </em><em>coreBN.models.GaussianDistribution</em>) -- </p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grad_logp</span><span class="p">,</span> <span class="n">logp</span> <span class="o">=</span> <span class="n">GradLogPDFGaussian</span><span class="p">(</span><span class="n">dist_param</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">get_gradient_log_pdf</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.base.LeapFrog">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.base.</span></span><span class="sig-name descname"><span class="pre">LeapFrog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">momentum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_pdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#LeapFrog"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.base.LeapFrog" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#coreBN.sampling.base.BaseSimulateHamiltonianDynamics" title="coreBN.sampling.base.BaseSimulateHamiltonianDynamics"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseSimulateHamiltonianDynamics</span></code></a></p>
<p>Class for simulating hamiltonian dynamics using leapfrog method
Inherits coreBN.inference.base_continuous.BaseSimulateHamiltonianDynamics</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>An instance</em><em> of </em><em>coreBN.models</em>) -- Model for which DiscretizeTime object is initialized</p></li>
<li><p><strong>position</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing values of parameter position( or X)</p></li>
<li><p><strong>momentum</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing the proposed value for momentum (velocity)</p></li>
<li><p><strong>stepsize</strong> (<em>Float</em>) -- stepsize for the simulating dynamics</p></li>
<li><p><strong>grad_log_pdf</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseGradLogPDF</em><em>, </em><em>defaults to None</em>) -- A class for evaluating gradient log and log of distribution for a given assignment of variables
If None, then model.get_gradient_log_pdf will be used</p></li>
<li><p><strong>grad_log_position</strong> (<em>A 1d array like object</em><em>, </em><em>defaults to None</em>) -- Vector representing gradient log at given position
If None, then will be calculated</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">LeapFrog</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span> <span class="k">as</span> <span class="n">GLPG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">momentum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span><span class="p">,</span> <span class="n">new_momentum</span><span class="p">,</span> <span class="n">new_grad</span> <span class="o">=</span> <span class="n">LeapFrog</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">GLPG</span><span class="p">)</span><span class="o">.</span><span class="n">get_proposed_values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span>
<span class="go">array([ 70., -19.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_momentum</span>
<span class="go">array([  99., -121.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_grad</span>
<span class="go">array([ 41., -58.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.base.ModifiedEuler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.base.</span></span><span class="sig-name descname"><span class="pre">ModifiedEuler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">momentum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_pdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#ModifiedEuler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.base.ModifiedEuler" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#coreBN.sampling.base.BaseSimulateHamiltonianDynamics" title="coreBN.sampling.base.BaseSimulateHamiltonianDynamics"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseSimulateHamiltonianDynamics</span></code></a></p>
<p>Class for simulating Hamiltonian Dynamics using Modified euler method
Inherits coreBN.inference.base_continuous.BaseSimulateHamiltonianDynamics</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>An instance</em><em> of </em><em>coreBN.models</em>) -- Model for which DiscretizeTime object is initialized</p></li>
<li><p><strong>position</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing values of parameter position( or X)</p></li>
<li><p><strong>momentum</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing the proposed value for momentum (velocity)</p></li>
<li><p><strong>stepsize</strong> (<em>Float</em>) -- stepsize for the simulating dynamics</p></li>
<li><p><strong>grad_log_pdf</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseGradLogPDF</em><em>, </em><em>defaults to None</em>) -- A class for finding gradient log and log of distribution
If None, then will use model.get_gradient_log_pdf</p></li>
<li><p><strong>grad_log_position</strong> (<em>A 1d array like object</em><em>, </em><em>defaults to None</em>) -- Vector representing gradient log at given position
If None, then will be calculated</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">ModifiedEuler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">momentum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span><span class="p">,</span> <span class="n">new_momentum</span><span class="p">,</span> <span class="n">new_grad</span> <span class="o">=</span> <span class="n">ModifiedEuler</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span>
<span class="gp">... </span>                                                <span class="mf">0.25</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span><span class="p">)</span><span class="o">.</span><span class="n">get_proposed_values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span>
<span class="go">array([2.125, 1.1875])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_momentum</span>
<span class="go">array([0.5, 0.75])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_grad</span>
<span class="go">array([-2.125, -1.1875])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-coreBN.sampling">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-coreBN.sampling" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.BaseGradLogPDF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.</span></span><span class="sig-name descname"><span class="pre">BaseGradLogPDF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable_assignments</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#BaseGradLogPDF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.BaseGradLogPDF" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for evaluating gradient log of probability density function/ distribution</p>
<p>Classes inheriting this base class can be passed as an argument for
finding gradient log of probability distribution in inference algorithms</p>
<p>The class should initialize  self.grad_log and self.log_pdf</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variable_assignments</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing values(assignments) of variables at which we want to find gradient and log</p></li>
<li><p><strong>model</strong> (<em>An instance</em><em> of </em><em>coreBN.models</em>) -- </p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.inference.continuous</span> <span class="kn">import</span> <span class="n">BaseGradLogPDF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">GradLogGaussian</span><span class="p">(</span><span class="n">BaseGradLogPDF</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">BaseGradLogPDF</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">grad_log</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gradient_log_pdf</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_get_gradient_log_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">sub_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mean</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="gp">... </span>        <span class="n">grad</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">precision_matrix</span><span class="p">,</span> <span class="n">sub_vec</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">log_pdf</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sub_vec</span><span class="p">,</span> <span class="n">grad</span><span class="p">))</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">grad</span><span class="p">,</span> <span class="n">log_pdf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grad_logp</span><span class="p">,</span> <span class="n">logp</span> <span class="o">=</span> <span class="n">GradLogGaussian</span><span class="p">(</span><span class="n">dist_param</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">get_gradient_log_pdf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logp</span>
<span class="go">-0.4054597701149426</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grad_logp</span>
<span class="go">array([ 0.90229885, -0.01149425])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.BaseGradLogPDF.get_gradient_log_pdf">
<span class="sig-name descname"><span class="pre">get_gradient_log_pdf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#BaseGradLogPDF.get_gradient_log_pdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.BaseGradLogPDF.get_gradient_log_pdf" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gradient log and log of model at given position</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>Returns a tuple of following types</em></p></li>
<li><p><strong>numpy.array</strong> (<em>Representing gradient log of model at given position</em>)</p></li>
<li><p><strong>float</strong> (<em>Representing log of model at given position</em>)</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Using implementation of GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling.base</span> <span class="kn">import</span> <span class="n">GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grad_logp</span><span class="p">,</span> <span class="n">logp</span> <span class="o">=</span> <span class="n">GradLogPDFGaussian</span><span class="p">(</span><span class="n">dist_param</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">get_gradient_log_pdf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logp</span>
<span class="go">0.025217391304347823</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grad_logp</span>
<span class="go">array([-0.07826087, -0.09565217])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.BaseSimulateHamiltonianDynamics">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.</span></span><span class="sig-name descname"><span class="pre">BaseSimulateHamiltonianDynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">momentum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_pdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#BaseSimulateHamiltonianDynamics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.BaseSimulateHamiltonianDynamics" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for proposing new values of position and momentum by simulating Hamiltonian Dynamics.</p>
<p>Classes inheriting this base class can be passed as an argument for
simulate_dynamics in inference algorithms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>An instance</em><em> of </em><em>coreBN.models</em>) -- Model for which DiscretizeTime object is initialized</p></li>
<li><p><strong>position</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing values of parameter position( or X)</p></li>
<li><p><strong>momentum</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing the proposed value for momentum (velocity)</p></li>
<li><p><strong>stepsize</strong> (<em>Float</em>) -- stepsize for the simulating dynamics</p></li>
<li><p><strong>grad_log_pdf</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseGradLogPDF</em>) -- A class for finding gradient log and log of distribution</p></li>
<li><p><strong>grad_log_position</strong> (<em>A 1d array like object</em><em>, </em><em>defaults to None</em>) -- Vector representing gradient log at given position
If None, then will be calculated</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">BaseSimulateHamiltonianDynamics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Class should initalize self.new_position, self.new_momentum and self.new_grad_logp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># self.new_grad_logp represents gradient log at new proposed value of position</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ModifiedEuler</span><span class="p">(</span><span class="n">BaseSimulateHamiltonianDynamics</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="n">stepsize</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="p">,</span> <span class="n">grad_log_position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">BaseSimulateHamiltonianDynamics</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">stepsize</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="p">,</span> <span class="n">grad_log_position</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">new_position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_momentum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_grad_logp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_proposed_values</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_get_proposed_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">momentum_bar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">momentum</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepsize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_log_position</span>
<span class="gp">... </span>        <span class="n">position_bar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepsize</span> <span class="o">*</span> <span class="n">momentum_bar</span>
<span class="gp">... </span>        <span class="n">grad_log_position</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_log_pdf</span><span class="p">(</span><span class="n">position_bar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">get_gradient_log_pdf</span><span class="p">()</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">position_bar</span><span class="p">,</span> <span class="n">momentum_bar</span><span class="p">,</span> <span class="n">grad_log_position</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">momentum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span><span class="p">,</span> <span class="n">new_momentum</span><span class="p">,</span> <span class="n">new_grad</span> <span class="o">=</span> <span class="n">ModifiedEuler</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span>
<span class="gp">... </span>                                                <span class="mf">0.25</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span><span class="p">)</span><span class="o">.</span><span class="n">get_proposed_values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span>
<span class="go">array([0.9375, 1.875])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_momentum</span>
<span class="go">array([-0.25, -0.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_grad</span>
<span class="go">array([-0.9375, -1.875])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.BaseSimulateHamiltonianDynamics.get_proposed_values">
<span class="sig-name descname"><span class="pre">get_proposed_values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#BaseSimulateHamiltonianDynamics.get_proposed_values"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.BaseSimulateHamiltonianDynamics.get_proposed_values" title="Permalink to this definition"></a></dt>
<dd><p>Returns the new proposed values of position and momentum</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>Returns a tuple of following type (in order)</em></p></li>
<li><p><strong>numpy.array</strong> (<em>A 1d numpy.array representing new proposed value of position</em>)</p></li>
<li><p><strong>numpy.array</strong> (<em>A 1d numpy.array representing new proposed value of momentum</em>)</p></li>
<li><p><strong>numpy.array</strong> (<em>A 1d numpy.array representing gradient of log distribution at new proposed value of position</em>)</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Using implementation of ModifiedEuler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.inference.continuous</span> <span class="kn">import</span> <span class="n">ModifiedEuler</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span> <span class="k">as</span> <span class="n">GLPG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">momentum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span><span class="p">,</span> <span class="n">new_momentum</span><span class="p">,</span> <span class="n">new_grad</span> <span class="o">=</span> <span class="n">ModifiedEuler</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="mf">0.70</span><span class="p">,</span> <span class="n">GLPG</span><span class="p">)</span><span class="o">.</span><span class="n">get_proposed_values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span>
<span class="go">array([ 3.04666667,  4.21      ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_momentum</span>
<span class="go">array([ 0.06666667,  0.3       ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_grad</span>
<span class="go">array([-1.34888889, -1.07      ])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.BayesianModelSampling">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.</span></span><span class="sig-name descname"><span class="pre">BayesianModelSampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/Sampling.html#BayesianModelSampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.BayesianModelSampling" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#coreBN.sampling.base.BayesianModelInference" title="coreBN.sampling.base.BayesianModelInference"><code class="xref py py-class docutils literal notranslate"><span class="pre">BayesianModelInference</span></code></a></p>
<p>Class for sampling methods specific to Bayesian Models</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>model</strong> (<em>instance</em><em> of </em><a class="reference internal" href="coreBN.models.html#coreBN.models.BayesianNetwork" title="coreBN.models.BayesianNetwork"><em>BayesianNetwork</em></a>) -- model on which inference queries will be computed</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.BayesianModelSampling.forward_sample">
<span class="sig-name descname"><span class="pre">forward_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partial_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/Sampling.html#BayesianModelSampling.forward_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.BayesianModelSampling.forward_sample" title="Permalink to this definition"></a></dt>
<dd><p>Generates sample(s) from joint distribution of the bayesian network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) -- size of sample to be generated</p></li>
<li><p><strong>include_latents</strong> (<em>boolean</em>) -- Whether to include the latent variable values in the generated samples.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> (</em><em>default: None</em><em>)</em>) -- If a value is provided, sets the seed for numpy.random.</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) -- Whether to show a progress bar of samples getting generated.</p></li>
<li><p><strong>partial_samples</strong> (<em>pandas.DataFrame</em>) -- A pandas dataframe specifying samples on some of the variables in the model. If
specified, the sampling procedure uses these sample values, instead of generating them.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong> -- The generated samples</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.models</span> <span class="kn">import</span> <span class="n">BayesianNetwork</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">TabularCPD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">BayesianModelSampling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">BayesianNetwork</span><span class="p">([(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_d</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_i</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_g</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;grade&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span>
<span class="gp">... </span>               <span class="mf">0.08</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;diff&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_cpds</span><span class="p">(</span><span class="n">cpd_d</span><span class="p">,</span> <span class="n">cpd_i</span><span class="p">,</span> <span class="n">cpd_g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inference</span> <span class="o">=</span> <span class="n">BayesianModelSampling</span><span class="p">(</span><span class="n">student</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inference</span><span class="o">.</span><span class="n">forward_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">rec.array([(0, 0, 1), (1, 0, 2)], dtype=</span>
<span class="go">          [(&#39;diff&#39;, &#39;&lt;i8&#39;), (&#39;intel&#39;, &#39;&lt;i8&#39;), (&#39;grade&#39;, &#39;&lt;i8&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.BayesianModelSampling.likelihood_weighted_sample">
<span class="sig-name descname"><span class="pre">likelihood_weighted_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evidence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/Sampling.html#BayesianModelSampling.likelihood_weighted_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.BayesianModelSampling.likelihood_weighted_sample" title="Permalink to this definition"></a></dt>
<dd><p>Generates weighted sample(s) from joint distribution of the bayesian
network, that comply with the given evidence.
'Probabilistic Graphical Model Principles and Techniques', Koller and
Friedman, Algorithm 12.2 pp 493.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>evidence</strong> (list of <cite>core.factor.State</cite> namedtuples) -- None if no evidence</p></li>
<li><p><strong>size</strong> (<em>int</em>) -- size of sample to be generated</p></li>
<li><p><strong>include_latents</strong> (<em>boolean</em>) -- Whether to include the latent variable values in the generated samples.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> (</em><em>default: None</em><em>)</em>) -- If a value is provided, sets the seed for numpy.random.</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) -- Whether to show a progress bar of samples getting generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong> -- The generated samples with corresponding weights</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A pandas.DataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">State</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.models</span> <span class="kn">import</span> <span class="n">BayesianNetwork</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">TabularCPD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">BayesianModelSampling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">BayesianNetwork</span><span class="p">([(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_d</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_i</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_g</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;grade&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span>
<span class="gp">... </span>        <span class="mf">0.08</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]],</span>
<span class="gp">... </span>        <span class="p">[</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;diff&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_cpds</span><span class="p">(</span><span class="n">cpd_d</span><span class="p">,</span> <span class="n">cpd_i</span><span class="p">,</span> <span class="n">cpd_g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inference</span> <span class="o">=</span> <span class="n">BayesianModelSampling</span><span class="p">(</span><span class="n">student</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evidence</span> <span class="o">=</span> <span class="p">[</span><span class="n">State</span><span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inference</span><span class="o">.</span><span class="n">likelihood_weighted_sample</span><span class="p">(</span><span class="n">evidence</span><span class="o">=</span><span class="n">evidence</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;recarray&#39;</span><span class="p">)</span>
<span class="go">rec.array([(0, 0, 1, 0.6), (0, 0, 2, 0.6)], dtype=</span>
<span class="go">          [(&#39;diff&#39;, &#39;&lt;i8&#39;), (&#39;intel&#39;, &#39;&lt;i8&#39;), (&#39;grade&#39;, &#39;&lt;i8&#39;), (&#39;_weight&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.BayesianModelSampling.rejection_sample">
<span class="sig-name descname"><span class="pre">rejection_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evidence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partial_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/Sampling.html#BayesianModelSampling.rejection_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.BayesianModelSampling.rejection_sample" title="Permalink to this definition"></a></dt>
<dd><p>Generates sample(s) from joint distribution of the bayesian network,
given the evidence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>evidence</strong> (list of <cite>core.factor.State</cite> namedtuples) -- None if no evidence</p></li>
<li><p><strong>size</strong> (<em>int</em>) -- size of sample to be generated</p></li>
<li><p><strong>include_latents</strong> (<em>boolean</em>) -- Whether to include the latent variable values in the generated samples.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> (</em><em>default: None</em><em>)</em>) -- If a value is provided, sets the seed for numpy.random.</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) -- Whether to show a progress bar of samples getting generated.</p></li>
<li><p><strong>partial_samples</strong> (<em>pandas.DataFrame</em>) -- A pandas dataframe specifying samples on some of the variables in the model. If
specified, the sampling procedure uses these sample values, instead of generating them.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong> -- The generated samples</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.models</span> <span class="kn">import</span> <span class="n">BayesianNetwork</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">TabularCPD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">State</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">BayesianModelSampling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">BayesianNetwork</span><span class="p">([(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_d</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_i</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpd_g</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;grade&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span>
<span class="gp">... </span>               <span class="mf">0.08</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;diff&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_cpds</span><span class="p">(</span><span class="n">cpd_d</span><span class="p">,</span> <span class="n">cpd_i</span><span class="p">,</span> <span class="n">cpd_g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inference</span> <span class="o">=</span> <span class="n">BayesianModelSampling</span><span class="p">(</span><span class="n">student</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evidence</span> <span class="o">=</span> <span class="p">[</span><span class="n">State</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inference</span><span class="o">.</span><span class="n">rejection_sample</span><span class="p">(</span><span class="n">evidence</span><span class="o">=</span><span class="n">evidence</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;dataframe&#39;</span><span class="p">)</span>
<span class="go">        intel       diff       grade</span>
<span class="go">0         0          0          1</span>
<span class="go">1         0          0          1</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.GibbsSampling">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.</span></span><span class="sig-name descname"><span class="pre">GibbsSampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/Sampling.html#GibbsSampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.GibbsSampling" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="coreBN.models.html#coreBN.models.MarkovChain.MarkovChain" title="coreBN.models.MarkovChain.MarkovChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">MarkovChain</span></code></a></p>
<p>Class for performing Gibbs sampling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>model</strong> (<a class="reference internal" href="coreBN.models.html#coreBN.models.BayesianNetwork" title="coreBN.models.BayesianNetwork"><em>BayesianNetwork</em></a><em> or </em><a class="reference internal" href="coreBN.models.html#coreBN.models.MarkovNetwork" title="coreBN.models.MarkovNetwork"><em>MarkovNetwork</em></a>) -- Model from which variables are inherited and transition probabilities computed.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Initialization from a BayesianNetwork object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">TabularCPD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.models</span> <span class="kn">import</span> <span class="n">BayesianNetwork</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intel_cpd</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sat_cpd</span> <span class="o">=</span> <span class="n">TabularCPD</span><span class="p">(</span><span class="s1">&#39;sat&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">]],</span> <span class="n">evidence</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;intel&#39;</span><span class="p">],</span> <span class="n">evidence_card</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">BayesianNetwork</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;sat&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;sat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_cpds</span><span class="p">(</span><span class="n">intel_cpd</span><span class="p">,</span> <span class="n">sat_cpd</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">GibbsSampling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gibbs_chain</span> <span class="o">=</span> <span class="n">GibbsSampling</span><span class="p">(</span><span class="n">student</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gibbs_chain</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">   intel  sat</span>
<span class="go">0      0    0</span>
<span class="go">1      0    0</span>
<span class="go">2      1    1</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.GibbsSampling.generate_sample">
<span class="sig-name descname"><span class="pre">generate_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/Sampling.html#GibbsSampling.generate_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.GibbsSampling.generate_sample" title="Permalink to this definition"></a></dt>
<dd><p>Generator version of self.sample</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of State namedtuples, representing the assignment to all variables of the model.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">DiscreteFactor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">GibbsSampling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.models</span> <span class="kn">import</span> <span class="n">MarkovNetwork</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">MarkovNetwork</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_ab</span> <span class="o">=</span> <span class="n">DiscreteFactor</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_cb</span> <span class="o">=</span> <span class="n">DiscreteFactor</span><span class="p">([</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">add_factors</span><span class="p">(</span><span class="n">factor_ab</span><span class="p">,</span> <span class="n">factor_cb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gibbs</span> <span class="o">=</span> <span class="n">GibbsSampling</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">gibbs</span><span class="o">.</span><span class="n">generate_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">sample</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">]</span>
<span class="go">[[State(var=&#39;C&#39;, state=1), State(var=&#39;B&#39;, state=1), State(var=&#39;A&#39;, state=0)],</span>
<span class="go"> [State(var=&#39;C&#39;, state=0), State(var=&#39;B&#39;, state=1), State(var=&#39;A&#39;, state=1)]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.GibbsSampling.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/Sampling.html#GibbsSampling.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.GibbsSampling.sample" title="Permalink to this definition"></a></dt>
<dd><p>Sample from the Markov Chain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_state</strong> (<em>dict</em><em> or </em><em>array-like iterable</em>) -- Representing the starting states of the variables. If None is passed, a random start_state is chosen.</p></li>
<li><p><strong>size</strong> (<em>int</em>) -- Number of samples to be generated.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> (</em><em>default: None</em><em>)</em>) -- If a value is provided, sets the seed for numpy.random.</p></li>
<li><p><strong>include_latents</strong> (<em>boolean</em>) -- Whether to include the latent variable values in the generated samples.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong> -- The generated samples</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">DiscreteFactor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">GibbsSampling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.models</span> <span class="kn">import</span> <span class="n">MarkovNetwork</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">MarkovNetwork</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_ab</span> <span class="o">=</span> <span class="n">DiscreteFactor</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_cb</span> <span class="o">=</span> <span class="n">DiscreteFactor</span><span class="p">([</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">add_factors</span><span class="p">(</span><span class="n">factor_ab</span><span class="p">,</span> <span class="n">factor_cb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gibbs</span> <span class="o">=</span> <span class="n">GibbsSampling</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gibbs</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">return_tupe</span><span class="o">=</span><span class="s1">&#39;dataframe&#39;</span><span class="p">)</span>
<span class="go">   A  B  C</span>
<span class="go">0  0  1  1</span>
<span class="go">1  1  0  0</span>
<span class="go">2  1  1  0</span>
<span class="go">3  1  1  1</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.GradLogPDFGaussian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.</span></span><span class="sig-name descname"><span class="pre">GradLogPDFGaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable_assignments</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#GradLogPDFGaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.GradLogPDFGaussian" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#coreBN.sampling.base.BaseGradLogPDF" title="coreBN.sampling.base.BaseGradLogPDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseGradLogPDF</span></code></a></p>
<p>Class for finding gradient and gradient log of Joint Gaussian Distribution
Inherits coreBN.inference.base_continuous.BaseGradLogPDF
Here model must be an instance of GaussianDistribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variable_assignments</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing values of variables at which we want to find gradient and log</p></li>
<li><p><strong>model</strong> (<em>An instance</em><em> of </em><em>coreBN.models.GaussianDistribution</em>) -- </p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grad_logp</span><span class="p">,</span> <span class="n">logp</span> <span class="o">=</span> <span class="n">GradLogPDFGaussian</span><span class="p">(</span><span class="n">dist_param</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">get_gradient_log_pdf</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.HamiltonianMC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.</span></span><span class="sig-name descname"><span class="pre">HamiltonianMC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_pdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulate_dynamics=&lt;class</span> <span class="pre">'coreBN.sampling.base.LeapFrog'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/HMC.html#HamiltonianMC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.HamiltonianMC" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class for performing sampling using simple
Hamiltonian Monte Carlo</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>An instance coreBN.models</em>) -- Model from which sampling has to be done</p></li>
<li><p><strong>grad_log_pdf</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseGradLogPDF</em><em>, </em><em>defaults to None</em>) -- A class to find log and gradient of log distribution for a given assignment
If None, then will use model.get_gradient_log_pdf</p></li>
<li><p><strong>simulate_dynamics</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseSimulateHamiltonianDynamics</em>) -- A class to propose future values of momentum and position in time by simulating
Hamiltonian Dynamics</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">HamiltonianMC</span> <span class="k">as</span> <span class="n">HMC</span><span class="p">,</span> <span class="n">LeapFrog</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">HMC</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">simulate_dynamics</span><span class="o">=</span><span class="n">LeapFrog</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">initial_pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">trajectory_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;recarray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">rec.array([(1.0, 1.0), (-3.1861687131079086, 3.7940994520145654),</span>
<span class="go"> (-1.6920542547310844, 6.347410703806017), ...,</span>
<span class="go"> (-1.8093621120575312, 5.940860883943261),</span>
<span class="go"> (0.3933248026088032, 6.3853098838119235),</span>
<span class="go"> (-0.8654072934719572, 6.023803629334816)],</span>
<span class="go">          dtype=[(&#39;x&#39;, &#39;&lt;f8&#39;), (&#39;y&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">samples</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="go">array([[ 3.0352818 ,  0.71379304],</span>
<span class="go">       [ 0.71379304,  4.91776713]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">.</span><span class="n">accepted_proposals</span>
<span class="go">9932.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">.</span><span class="n">acceptance_rate</span>
<span class="go">0.9932</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>R.Neal. Handbook of Markov Chain Monte Carlo,
chapter 5: MCMC Using Hamiltonian Dynamics.
CRC Press, 2011.</p>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.HamiltonianMC.generate_sample">
<span class="sig-name descname"><span class="pre">generate_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajectory_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/HMC.html#HamiltonianMC.generate_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.HamiltonianMC.generate_sample" title="Permalink to this definition"></a></dt>
<dd><p>Method returns a generator type object whose each iteration yields a sample
using Hamiltonian Monte Carlo</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>trajectory_length</strong> (<em>int</em><em> or </em><em>float</em>) -- Target trajectory length, stepsize * number of steps(L),
where L is the number of steps taken per HMC iteration,
and stepsize is step size for splitting time method.</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be chosen suitably</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>genrator</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>yielding a 1d numpy.array type object for a sample</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">HamiltonianMC</span> <span class="k">as</span> <span class="n">HMC</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span> <span class="k">as</span> <span class="n">GLPG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">HMC</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GLPG</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen_samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">generate_sample</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">trajectory_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sample</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">gen_samples</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples_array</span>
<span class="go">array([[ 0.1467264 ,  0.27143857],</span>
<span class="go">       [ 4.0371448 ,  0.15871274],</span>
<span class="go">       [ 3.24656208, -1.03742621],</span>
<span class="go">       ...,</span>
<span class="go">       [ 6.45975905,  1.97941306],</span>
<span class="go">       [ 4.89007171,  0.15413156],</span>
<span class="go">       [ 5.9528083 ,  1.92983158]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">samples_array</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="go">array([[ 2.95692642,  0.4379419 ],</span>
<span class="go">       [ 0.4379419 ,  3.00939434]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">.</span><span class="n">acceptance_rate</span>
<span class="go">0.9969</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.HamiltonianMC.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajectory_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dataframe'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/HMC.html#HamiltonianMC.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.HamiltonianMC.sample" title="Permalink to this definition"></a></dt>
<dd><p>Method to return samples using Hamiltonian Monte Carlo</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>trajectory_length</strong> (<em>int</em><em> or </em><em>float</em>) -- Target trajectory length, stepsize * number of steps(L),
where L is the number of steps taken per HMC iteration,
and stepsize is step size for splitting time method.</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be chosen suitably</p></li>
<li><p><strong>return_type</strong> (<em>string</em><em> (</em><em>dataframe</em><em> | </em><em>recarray</em><em>)</em>) -- Return type for samples, either of 'dataframe' or 'recarray'.
Defaults to 'dataframe'</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A pandas.DataFrame or a numpy.recarray object depending upon return_type argument</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">HamiltonianMC</span> <span class="k">as</span> <span class="n">HMC</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">ModifiedEuler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">HMC</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">simulate_dynamics</span><span class="o">=</span><span class="n">ModifiedEuler</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">trajectory_length</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;dataframe&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">               x              y</span>
<span class="go">0   1.000000e+00   1.000000e+00</span>
<span class="go">1   1.592133e+00   1.152911e+00</span>
<span class="go">2   1.608700e+00   1.315349e+00</span>
<span class="go">3   1.608700e+00   1.315349e+00</span>
<span class="go">4   6.843856e-01   6.237043e-01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.7</span> <span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">HMC</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GLPG</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">trajectory_length</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;dataframe&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="go">array([[ 1.00795398,  0.71384233,  0.79802097],</span>
<span class="go">       [ 0.71384233,  1.00633524,  0.21313767],</span>
<span class="go">       [ 0.79802097,  0.21313767,  0.98519017]])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.HamiltonianMCDA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.</span></span><span class="sig-name descname"><span class="pre">HamiltonianMCDA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_pdf=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulate_dynamics=&lt;class</span> <span class="pre">'coreBN.sampling.base.LeapFrog'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta=0.65</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/HMC.html#HamiltonianMCDA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.HamiltonianMCDA" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#coreBN.sampling.HMC.HamiltonianMC" title="coreBN.sampling.HMC.HamiltonianMC"><code class="xref py py-class docutils literal notranslate"><span class="pre">HamiltonianMC</span></code></a></p>
<p>Class for performing sampling in Continuous model
using Hamiltonian Monte Carlo with dual averaging for
adaptaion of parameter stepsize.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>An instance coreBN.models</em>) -- Model from which sampling has to be done</p></li>
<li><p><strong>grad_log_pdf</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.GradientLogPDF</em>) -- Class to compute the log and gradient log of distribution</p></li>
<li><p><strong>simulate_dynamics</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseSimulateHamiltonianDynamics</em>) -- Class to propose future states of position and momentum in time by simulating
HamiltonianDynamics</p></li>
<li><p><strong>delta</strong> (<em>float</em><em> (</em><em>in between 0 and 1</em><em>)</em><em>, </em><em>defaults to 0.65</em>) -- The target HMC acceptance probability</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">HamiltonianMCDA</span> <span class="k">as</span> <span class="n">HMCda</span><span class="p">,</span> <span class="n">LeapFrog</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span> <span class="k">as</span> <span class="n">GLPG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">HMCda</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GLPG</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">num_adapt</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">trajectory_length</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;recarray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">samples</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">samples_array</span><span class="p">)</span>
<span class="go">array([[ 1.83023816,  0.40449162,  0.51200707],</span>
<span class="go">       [ 0.40449162,  2.85863596,  0.76747343],</span>
<span class="go">       [ 0.51200707,  0.76747343,  3.87020982]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">.</span><span class="n">acceptance_rate</span>
<span class="go">0.9929</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>Matthew D. Hoffman, Andrew Gelman, The No-U-Turn Sampler: Adaptively
Setting Path Lengths in Hamiltonian Monte Carlo. Journal of
Machine Learning Research 15 (2014) 1351-1381
Algorithm 5 : Hamiltonian Monte Carlo with dual averaging</p>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.HamiltonianMCDA.generate_sample">
<span class="sig-name descname"><span class="pre">generate_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_adapt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajectory_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/HMC.html#HamiltonianMCDA.generate_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.HamiltonianMCDA.generate_sample" title="Permalink to this definition"></a></dt>
<dd><p>Method returns a generator type object whose each iteration yields a sample
using Hamiltonian Monte Carlo</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_adapt</strong> (<em>int</em>) -- The number of iterations to run the adaptation of stepsize</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>trajectory_length</strong> (<em>int</em><em> or </em><em>float</em>) -- Target trajectory length, stepsize * number of steps(L),
where L is the number of steps taken to propose new values of position and momentum
per HMC iteration and stepsize is step size.</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be chosen suitably</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>genrator</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>yielding a numpy.array type object for a sample</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">HamiltonianMCDA</span> <span class="k">as</span> <span class="n">HMCda</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span> <span class="k">as</span> <span class="n">GLPG</span><span class="p">,</span> <span class="n">LeapFrog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">HMCda</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GLPG</span><span class="p">,</span> <span class="n">simulate_dynamics</span><span class="o">=</span><span class="n">LeapFrog</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen_samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">generate_sample</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_adapt</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">trajectory_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sample</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">gen_samples</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">samples_array</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="go">array([[ 0.98432155,  0.69517394],</span>
<span class="go">       [ 0.69517394,  2.95449533]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.HamiltonianMCDA.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_adapt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajectory_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dataframe'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/HMC.html#HamiltonianMCDA.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.HamiltonianMCDA.sample" title="Permalink to this definition"></a></dt>
<dd><p>Method to return samples using Hamiltonian Monte Carlo</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_adapt</strong> (<em>int</em>) -- The number of iterations to run the adaptation of stepsize</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>trajectory_length</strong> (<em>int</em><em> or </em><em>float</em>) -- Target trajectory length, stepsize * number of steps(L),
where L is the number of steps taken per HMC iteration,
and stepsize is step size for splitting time method.</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be chosen suitably</p></li>
<li><p><strong>return_type</strong> (<em>string</em><em> (</em><em>dataframe</em><em> | </em><em>recarray</em><em>)</em>) -- Return type for samples, either of 'dataframe' or 'recarray'.
Defaults to 'dataframe'</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A pandas.DataFrame or a numpy.recarray object depending upon return_type argument</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">HamiltonianMCDA</span> <span class="k">as</span> <span class="n">HMCda</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span> <span class="k">as</span> <span class="n">GLPG</span><span class="p">,</span> <span class="n">LeapFrog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">HMCda</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GLPG</span><span class="p">,</span> <span class="n">simulate_dynamics</span><span class="o">=</span><span class="n">LeapFrog</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_adapt</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">trajectory_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;recarray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">samples</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">samples_array</span><span class="p">)</span>
<span class="go">array([[ 0.98432155,  0.66517394],</span>
<span class="go">       [ 0.66517394,  2.95449533]])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.LeapFrog">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.</span></span><span class="sig-name descname"><span class="pre">LeapFrog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">momentum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_pdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#LeapFrog"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.LeapFrog" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#coreBN.sampling.base.BaseSimulateHamiltonianDynamics" title="coreBN.sampling.base.BaseSimulateHamiltonianDynamics"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseSimulateHamiltonianDynamics</span></code></a></p>
<p>Class for simulating hamiltonian dynamics using leapfrog method
Inherits coreBN.inference.base_continuous.BaseSimulateHamiltonianDynamics</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>An instance</em><em> of </em><em>coreBN.models</em>) -- Model for which DiscretizeTime object is initialized</p></li>
<li><p><strong>position</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing values of parameter position( or X)</p></li>
<li><p><strong>momentum</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing the proposed value for momentum (velocity)</p></li>
<li><p><strong>stepsize</strong> (<em>Float</em>) -- stepsize for the simulating dynamics</p></li>
<li><p><strong>grad_log_pdf</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseGradLogPDF</em><em>, </em><em>defaults to None</em>) -- A class for evaluating gradient log and log of distribution for a given assignment of variables
If None, then model.get_gradient_log_pdf will be used</p></li>
<li><p><strong>grad_log_position</strong> (<em>A 1d array like object</em><em>, </em><em>defaults to None</em>) -- Vector representing gradient log at given position
If None, then will be calculated</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">LeapFrog</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span> <span class="k">as</span> <span class="n">GLPG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">momentum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span><span class="p">,</span> <span class="n">new_momentum</span><span class="p">,</span> <span class="n">new_grad</span> <span class="o">=</span> <span class="n">LeapFrog</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">GLPG</span><span class="p">)</span><span class="o">.</span><span class="n">get_proposed_values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span>
<span class="go">array([ 70., -19.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_momentum</span>
<span class="go">array([  99., -121.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_grad</span>
<span class="go">array([ 41., -58.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.ModifiedEuler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.</span></span><span class="sig-name descname"><span class="pre">ModifiedEuler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">momentum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_pdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/base.html#ModifiedEuler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.ModifiedEuler" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#coreBN.sampling.base.BaseSimulateHamiltonianDynamics" title="coreBN.sampling.base.BaseSimulateHamiltonianDynamics"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseSimulateHamiltonianDynamics</span></code></a></p>
<p>Class for simulating Hamiltonian Dynamics using Modified euler method
Inherits coreBN.inference.base_continuous.BaseSimulateHamiltonianDynamics</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>An instance</em><em> of </em><em>coreBN.models</em>) -- Model for which DiscretizeTime object is initialized</p></li>
<li><p><strong>position</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing values of parameter position( or X)</p></li>
<li><p><strong>momentum</strong> (<em>A 1d array like object</em><em> (</em><em>numpy.ndarray</em><em> or </em><em>list</em><em>)</em>) -- Vector representing the proposed value for momentum (velocity)</p></li>
<li><p><strong>stepsize</strong> (<em>Float</em>) -- stepsize for the simulating dynamics</p></li>
<li><p><strong>grad_log_pdf</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseGradLogPDF</em><em>, </em><em>defaults to None</em>) -- A class for finding gradient log and log of distribution
If None, then will use model.get_gradient_log_pdf</p></li>
<li><p><strong>grad_log_position</strong> (<em>A 1d array like object</em><em>, </em><em>defaults to None</em>) -- Vector representing gradient log at given position
If None, then will be calculated</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">ModifiedEuler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">momentum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span><span class="p">,</span> <span class="n">new_momentum</span><span class="p">,</span> <span class="n">new_grad</span> <span class="o">=</span> <span class="n">ModifiedEuler</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span>
<span class="gp">... </span>                                                <span class="mf">0.25</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span><span class="p">)</span><span class="o">.</span><span class="n">get_proposed_values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pos</span>
<span class="go">array([2.125, 1.1875])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_momentum</span>
<span class="go">array([0.5, 0.75])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_grad</span>
<span class="go">array([-2.125, -1.1875])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.NoUTurnSampler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.</span></span><span class="sig-name descname"><span class="pre">NoUTurnSampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_pdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulate_dynamics=&lt;class</span> <span class="pre">'coreBN.sampling.base.LeapFrog'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/NUTS.html#NoUTurnSampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.NoUTurnSampler" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#coreBN.sampling.HMC.HamiltonianMCDA" title="coreBN.sampling.HMC.HamiltonianMCDA"><code class="xref py py-class docutils literal notranslate"><span class="pre">HamiltonianMCDA</span></code></a></p>
<p>Class for performing sampling in Continuous model
using No U Turn Sampler (a variant of Hamiltonian Monte Carlo)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>An instance coreBN.models</em>) -- Model from which sampling has to be done</p></li>
<li><p><strong>grad_log_pdf</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.GradientLogPDF</em>) -- Class to compute the log and gradient log of distribution</p></li>
<li><p><strong>simulate_dynamics</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseSimulateHamiltonianDynamics</em>) -- Class to propose future states of position and momentum in time by simulating
HamiltonianDynamics</p></li>
<li><p><strong>Methods</strong> (<em>Public</em>) -- </p></li>
<li><p><strong>--------------</strong> -- </p></li>
<li><p><strong>sample</strong><strong>(</strong><strong>)</strong> -- </p></li>
<li><p><strong>generate_sample</strong><strong>(</strong><strong>)</strong> -- </p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">NoUTurnSampler</span> <span class="k">as</span> <span class="n">NUTS</span><span class="p">,</span> <span class="n">LeapFrog</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">NUTS</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">simulate_dynamics</span><span class="o">=</span><span class="n">LeapFrog</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">initial_pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]),</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;recarray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">rec.array([(0.1, 0.9, 0.3),</span>
<span class="go"> (-0.27303886844752756, 0.5028580705249155, 0.2895768065049909),</span>
<span class="go"> (1.7139810571103862, 2.809135711303245, 5.690811523613858), ...,</span>
<span class="go"> (-0.7742669710786649, 2.092867703984895, 6.139480724333439),</span>
<span class="go"> (1.3916152816323692, 1.394952482021687, 3.446906546649354),</span>
<span class="go"> (-0.2726336476939125, 2.6230854954595357, 2.923948403903159)],</span>
<span class="go">          dtype=[(&#39;x&#39;, &#39;&lt;f8&#39;), (&#39;y&#39;, &#39;&lt;f8&#39;), (&#39;z&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>Matthew D. Hoffman, Andrew Gelman, The No-U-Turn Sampler: Adaptively
Setting Path Lengths in Hamiltonian Monte Carlo. Journal of
Machine Learning Research 15 (2014) 1351-1381
Algorithm 3 : Efficient No-U-Turn Sampler</p>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.NoUTurnSampler.generate_sample">
<span class="sig-name descname"><span class="pre">generate_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/NUTS.html#NoUTurnSampler.generate_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.NoUTurnSampler.generate_sample" title="Permalink to this definition"></a></dt>
<dd><p>Returns a generator type object whose each iteration yields a sample</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be chosen suitably</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>generator</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>yielding a numpy.array type object for a sample</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">NoUTurnSampler</span> <span class="k">as</span> <span class="n">NUTS</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">14</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">NUTS</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GradLogPDFGaussian</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">generate_sample</span><span class="p">(</span><span class="n">initial_pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sample</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">array([[ 10.26357538,   0.10062725],</span>
<span class="go">       [ 12.70600336,   0.63392499],</span>
<span class="go">       [ 10.95523217,  -0.62079273],</span>
<span class="go">       [ 10.66263031,  -4.08135962],</span>
<span class="go">       [ 10.59255762,  -8.48085076],</span>
<span class="go">       [  9.99860242,  -9.47096032],</span>
<span class="go">       [ 10.5733564 ,  -9.83504745],</span>
<span class="go">       [ 11.51302059,  -9.49919523],</span>
<span class="go">       [ 11.31892143,  -8.5873259 ],</span>
<span class="go">       [ 11.29008667,  -0.43809674]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.NoUTurnSampler.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dataframe'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/NUTS.html#NoUTurnSampler.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.NoUTurnSampler.sample" title="Permalink to this definition"></a></dt>
<dd><p>Method to return samples using No U Turn Sampler</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be choosen suitably</p></li>
<li><p><strong>return_type</strong> (<em>string</em><em> (</em><em>dataframe</em><em> | </em><em>recarray</em><em>)</em>) -- Return type for samples, either of 'dataframe' or 'recarray'.
Defaults to 'dataframe'</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A pandas.DataFrame or a numpy.recarray object depending upon return_type argument</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">NoUTurnSampler</span> <span class="k">as</span> <span class="n">NUTS</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">LeapFrog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">6</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">NUTS</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">simulate_dynamics</span><span class="o">=</span><span class="n">LeapFrog</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">initial_pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;dataframe&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">          x         y         z</span>
<span class="go">0  1.000000  1.000000  1.000000</span>
<span class="go">1  1.760756  0.271543 -0.613309</span>
<span class="go">2  1.883387  0.990745 -0.611720</span>
<span class="go">3  0.980812  0.340336 -0.916283</span>
<span class="go">4  0.781338  0.647220 -0.948640</span>
<span class="go">5  0.040308 -1.391406  0.412201</span>
<span class="go">6  1.179549 -1.450552  1.105216</span>
<span class="go">7  1.100320 -1.313926  1.207815</span>
<span class="go">8  1.484520 -1.349247  0.768599</span>
<span class="go">9  0.934942 -1.894589  0.471772</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.sampling.NoUTurnSamplerDA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.sampling.</span></span><span class="sig-name descname"><span class="pre">NoUTurnSamplerDA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_log_pdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulate_dynamics=&lt;class</span> <span class="pre">'coreBN.sampling.base.LeapFrog'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta=0.65</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/NUTS.html#NoUTurnSamplerDA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.NoUTurnSamplerDA" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#coreBN.sampling.NUTS.NoUTurnSampler" title="coreBN.sampling.NUTS.NoUTurnSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">NoUTurnSampler</span></code></a></p>
<p>Class for performing sampling in Continuous model
using No U Turn sampler with dual averaging for
adaptation of parameter stepsize.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>An instance coreBN.models</em>) -- Model from which sampling has to be done</p></li>
<li><p><strong>grad_log_pdf</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.GradientLogPDF</em>) -- Class to compute the log and gradient log of distribution</p></li>
<li><p><strong>simulate_dynamics</strong> (<em>A subclass</em><em> of </em><em>coreBN.inference.continuous.BaseSimulateHamiltonianDynamics</em>) -- Class to propose future states of position and momentum in time by simulating
HamiltonianDynamics</p></li>
<li><p><strong>delta</strong> (<em>float</em><em> (</em><em>in between 0 and 1</em><em>)</em><em>, </em><em>defaults to 0.65</em>) -- The target HMC acceptance probability</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">NoUTurnSamplerDA</span> <span class="k">as</span> <span class="n">NUTSda</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">NUTSda</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GradLogPDFGaussian</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">initial_pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">num_adapt</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;recarray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">rec.array([(0.0, 0.0, 0.0),</span>
<span class="go"> (0.06100992691638076, -0.17118088764170125, 0.14048470935160887),</span>
<span class="go"> (0.06100992691638076, -0.17118088764170125, 0.14048470935160887),</span>
<span class="go"> (-0.7451883138013118, 1.7975387358691155, 2.3090698721374436),</span>
<span class="go"> (-0.6207457594500309, 1.4611049498441024, 2.5890867012835574),</span>
<span class="go"> (0.24043604780911487, 1.8660976216530618, 3.2508715592645347),</span>
<span class="go"> (0.21509819341468212, 2.157760225367607, 3.5749582768731476),</span>
<span class="go"> (0.20699150582681913, 2.0605044285377305, 3.8588980251618135),</span>
<span class="go"> (0.20699150582681913, 2.0605044285377305, 3.8588980251618135),</span>
<span class="go"> (0.085332419611991, 1.7556171374575567, 4.49985082288814)],</span>
<span class="go">          dtype=[(&#39;x&#39;, &#39;&lt;f8&#39;), (&#39;v&#39;, &#39;&lt;f8&#39;), (&#39;t&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>Matthew D. Hoffman, Andrew Gelman, The No-U-Turn Sampler: Adaptively
Setting Path Lengths in Hamiltonian Monte Carlo. Journal of
Machine Learning Research 15 (2014) 1351-1381
Algorithm 6 : No-U-Turn Sampler with Dual Averaging</p>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.NoUTurnSamplerDA.generate_sample">
<span class="sig-name descname"><span class="pre">generate_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_adapt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/NUTS.html#NoUTurnSamplerDA.generate_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.NoUTurnSamplerDA.generate_sample" title="Permalink to this definition"></a></dt>
<dd><p>Returns a generator type object whose each iteration yields a sample</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_adapt</strong> (<em>int</em>) -- The number of iterations to run the adaptation of stepsize</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be chosen suitably</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>generator</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>yielding a numpy.array type object for a sample</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.sampling.NoUTurnSamplerDA.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_adapt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dataframe'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/sampling/NUTS.html#NoUTurnSamplerDA.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.sampling.NoUTurnSamplerDA.sample" title="Permalink to this definition"></a></dt>
<dd><p>Returns samples using No U Turn Sampler with dual averaging</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_pos</strong> (<em>A 1d array like object</em>) -- Vector representing values of parameter position, the starting
state in markov chain.</p></li>
<li><p><strong>num_adapt</strong> (<em>int</em>) -- The number of iterations to run the adaptation of stepsize</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) -- Number of samples to be generated</p></li>
<li><p><strong>stepsize</strong> (<em>float</em><em> , </em><em>defaults to None</em>) -- The stepsize for proposing new values of position and momentum in simulate_dynamics
If None, then will be chosen suitably</p></li>
<li><p><strong>return_type</strong> (<em>string</em><em> (</em><em>dataframe</em><em> | </em><em>recarray</em><em>)</em>) -- Return type for samples, either of 'dataframe' or 'recarray'.
Defaults to 'dataframe'</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sampled</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A pandas.DataFrame or a numpy.recarray object depending upon return_type argument</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.sampling</span> <span class="kn">import</span> <span class="n">NoUTurnSamplerDA</span> <span class="k">as</span> <span class="n">NUTSda</span><span class="p">,</span> <span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">LeapFrog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.continuous</span> <span class="kn">import</span> <span class="n">GaussianDistribution</span> <span class="k">as</span> <span class="n">JGD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">13</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">JGD</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">NUTSda</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">grad_log_pdf</span><span class="o">=</span><span class="n">GradLogPDFGaussian</span><span class="p">,</span> <span class="n">simulate_dynamics</span><span class="o">=</span><span class="n">LeapFrog</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">initial_pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]),</span> <span class="n">num_adapt</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="s1">&#39;dataframe&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span>
<span class="go">           x          y</span>
<span class="go">0  12.000000  -4.000000</span>
<span class="go">1  11.864821  -3.696109</span>
<span class="go">2  10.546986  -4.892169</span>
<span class="go">3   8.526596 -21.555793</span>
<span class="go">4   8.526596 -21.555793</span>
<span class="go">5  11.343194  -6.353789</span>
<span class="go">6  -1.583269 -12.802931</span>
<span class="go">7  12.411957 -11.704859</span>
<span class="go">8  13.253336 -20.169492</span>
<span class="go">9  11.295901  -7.665058</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="coreBN.models.html" class="btn btn-neutral float-left" title="coreBN.models package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="coreBN.tests.html" class="btn btn-neutral float-right" title="coreBN.tests package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Serafina Di Gioia.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>