<!DOCTYPE html>
<html class="writer-html5" lang="English/Python">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>coreBN.base package &mdash; gABi 00.00.01 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="coreBN.estimators package" href="coreBN.estimators.html" />
    <link rel="prev" title="coreBN.IO package" href="coreBN.IO.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            gABi
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">coreBN</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="coreBN.html">coreBN package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="coreBN.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="coreBN.CItests.html">coreBN.CItests package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.IO.html">coreBN.IO package</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">coreBN.base package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.estimators.html">coreBN.estimators package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.extern.html">coreBN.extern package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.factors.html">coreBN.factors package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.independencies.html">coreBN.independencies package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.inference.html">coreBN.inference package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.metrics.html">coreBN.metrics package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.models.html">coreBN.models package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.sampling.html">coreBN.sampling package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.tests.html">coreBN.tests package</a></li>
<li class="toctree-l4"><a class="reference internal" href="coreBN.utils.html">coreBN.utils package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="coreBN.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="coreBN.html#module-coreBN.global_vars">coreBN.global_vars module</a></li>
<li class="toctree-l3"><a class="reference internal" href="coreBN.html#module-coreBN">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">gABi</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="modules.html">coreBN</a></li>
          <li class="breadcrumb-item"><a href="coreBN.html">coreBN package</a></li>
      <li class="breadcrumb-item active">coreBN.base package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/coreBN.base.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="corebn-base-package">
<h1>coreBN.base package<a class="headerlink" href="#corebn-base-package" title="Permalink to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</section>
<section id="module-coreBN.base.DAG">
<span id="corebn-base-dag-module"></span><h2>coreBN.base.DAG module<a class="headerlink" href="#module-coreBN.base.DAG" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.base.DAG.</span></span><span class="sig-name descname"><span class="pre">DAG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ebunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></p>
<p>Base class for all Directed Graphical Models.
Each node in the graph can represent either a random variable, <cite>Factor</cite>,
or a cluster of random variables. Edges in the graph represent the
dependencies between these.
:param data: Data to initialize graph. If data=None (default) an empty graph is</p>
<blockquote>
<div><p>created. The data can be an edge list or any Networkx graph object.</p>
</div></blockquote>
<dl class="field-list simple">
</dl>
<p class="rubric">Examples</p>
<p>Create an empty DAG with no nodes and no edges
&gt;&gt;&gt; from coreBN.base import DAG
&gt;&gt;&gt; G = DAG()
G can be grown in several ways:
<strong>Nodes:</strong>
Add one node at a time:
&gt;&gt;&gt; G.add_node(node='a')
Add the nodes from any container (a list, set or tuple or the nodes
from another graph).
&gt;&gt;&gt; G.add_nodes_from(nodes=['a', 'b'])
<strong>Edges:</strong>
G can also be grown by adding edges.
Add one edge,
&gt;&gt;&gt; G.add_edge(u='a', v='b')
a list of edges,
&gt;&gt;&gt; G.add_edges_from(ebunch=[('a', 'b'), ('b', 'c')])
If some edges connect nodes not yet in the model, the nodes
are added automatically. There are no errors when adding
nodes or edges that already exist.
<strong>Shortcuts:</strong>
Many common graph features allow python syntax for speed reporting.
&gt;&gt;&gt; 'a' in G     # check if node in graph
True
&gt;&gt;&gt; len(G)  # number of nodes in graph
3</p>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.active_trail_nodes">
<span class="sig-name descname"><span class="pre">active_trail_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.active_trail_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.active_trail_nodes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a dictionary with the given variables as keys and all the nodes reachable
from that respective variable as values.
:param variables: variables whose active trails are to be found.
:type variables: str or array like
:param observed: If given the active trails would be computed assuming these nodes to be</p>
<blockquote>
<div><p>observed.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>include_latents</strong> (<em>boolean</em><em> (</em><em>default: False</em><em>)</em>) -- Whether to include the latent variables in the returned active trail nodes.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grades&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grades&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grades&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">)</span>
<span class="go">{&#39;diff&#39;: {&#39;diff&#39;, &#39;grades&#39;}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">([</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;intel&#39;</span><span class="p">],</span> <span class="n">observed</span><span class="o">=</span><span class="s1">&#39;grades&#39;</span><span class="p">)</span>
<span class="go">{&#39;diff&#39;: {&#39;diff&#39;, &#39;intel&#39;}, &#39;intel&#39;: {&#39;diff&#39;, &#39;intel&#39;}}</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>Details of the algorithm can be found in 'Probabilistic Graphical Model
Principles and Techniques' - Koller and Friedman
Page 75 Algorithm 3.1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.add_edge">
<span class="sig-name descname"><span class="pre">add_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.add_edge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.add_edge" title="Permalink to this definition"></a></dt>
<dd><p>Add an edge between u and v.
The nodes u and v will be automatically added if they are
not already in the graph.
:param u: Nodes can be any hashable Python object.
:type u: nodes
:param v: Nodes can be any hashable Python object.
:type v: nodes
:param weight: The weight of the edge
:type weight: int, float (default=None)</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Charles&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="s1">&#39;Bob&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;)])</span>
<span class="go">When the node is not already present in the graph:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="s1">&#39;Ankur&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((&#39;Alice&#39;, &#39;Ankur&#39;, &#39;Bob&#39;, &#39;Charles&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;), (&#39;Alice&#39;, &#39;Ankur&#39;)])</span>
<span class="go">Adding edges with weight:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;Ankur&#39;</span><span class="p">,</span> <span class="s1">&#39;Maria&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;Ankur&#39;</span><span class="p">][</span><span class="s1">&#39;Maria&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.1}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.add_edges_from">
<span class="sig-name descname"><span class="pre">add_edges_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ebunch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.add_edges_from"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.add_edges_from" title="Permalink to this definition"></a></dt>
<dd><p>Add all the edges in ebunch.
If nodes referred in the ebunch are not already present, they
will be automatically added. Node names can be any hashable python
object.
<a href="#id1"><span class="problematic" id="id2">**</span></a>The behavior of adding weights is different than networkx.
:param ebunch: Each edge given in the container will be added to the graph.</p>
<blockquote>
<div><p>The edges must be given as 2-tuples (u, v).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>weights</strong> (<em>list</em><em>, </em><em>tuple</em><em> (</em><em>default=None</em><em>)</em>) -- A container of weights (int, float). The weight value at index i
is associated with the edge at index i.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Charles&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Charles&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;), (&#39;Bob&#39;, &#39;Charles&#39;)])</span>
<span class="go">When the node is not already in the model:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Ankur&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;, &#39;Ankur&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;), (&#39;Bob&#39;, &#39;Charles&#39;), (&#39;Alice&#39;, &#39;Ankur&#39;)])</span>
<span class="go">Adding edges with weights:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;Ankur&#39;</span><span class="p">,</span> <span class="s1">&#39;Maria&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Maria&#39;</span><span class="p">,</span> <span class="s1">&#39;Mason&#39;</span><span class="p">)],</span>
<span class="gp">... </span>                 <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;Ankur&#39;</span><span class="p">][</span><span class="s1">&#39;Maria&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;Maria&#39;</span><span class="p">][</span><span class="s1">&#39;Mason&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.5}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.add_node">
<span class="sig-name descname"><span class="pre">add_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.add_node"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.add_node" title="Permalink to this definition"></a></dt>
<dd><p>Adds a single node to the Graph.
:param node: The node to add to the graph.
:type node: str, int, or any hashable python object.
:param weight: The weight of the node.
:type weight: int, float
:param latent: Specifies whether the variable is latent or not.
:type latent: boolean (default: False)</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
<span class="go">[&#39;A&#39;]</span>
<span class="go">Adding a node with some weight.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="go">The weight of these nodes can be accessed as:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: None}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.add_nodes_from">
<span class="sig-name descname"><span class="pre">add_nodes_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.add_nodes_from"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.add_nodes_from" title="Permalink to this definition"></a></dt>
<dd><p>Add multiple nodes to the Graph.
<a href="#id3"><span class="problematic" id="id4">**</span></a>The behviour of adding weights is different than in networkx.
:param nodes: A container of nodes (list, dict, set, or any hashable python</p>
<blockquote>
<div><p>object).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>list</em><em>, </em><em>tuple</em><em> (</em><em>default=None</em><em>)</em>) -- A container of weights (int, float). The weight value at index i
is associated with the variable at index i.</p></li>
<li><p><strong>latent</strong> (<em>list</em><em>, </em><em>tuple</em><em> (</em><em>default=False</em><em>)</em>) -- A container of boolean. The value at index i tells whether the
node at index i is latent or not.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((&#39;A&#39;, &#39;B&#39;, &#39;C&#39;))</span>
<span class="go">Adding nodes with weights:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.6}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: None}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.do">
<span class="sig-name descname"><span class="pre">do</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.do"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.do" title="Permalink to this definition"></a></dt>
<dd><p>Applies the do operator to the graph and returns a new DAG with the
transformed graph.
The do-operator, do(X = x) has the effect of removing all edges from
the parents of X and setting X to the given value x.
:param nodes: The names of the nodes to apply the do-operator for.
:type nodes: list, array-like
:param inplace: If inplace=True, makes the changes to the current object,</p>
<blockquote>
<div><p>otherwise returns a new instance.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Modified DAG</strong> -- A new instance of DAG modified by the do-operator</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#coreBN.base.DAG" title="coreBN.base.DAG">coreBN.base.DAG</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Initialize a DAG
&gt;&gt;&gt; graph = DAG()
&gt;&gt;&gt; graph.add_edges_from([('X', 'A'),
...                       ('A', 'Y'),
...                       ('A', 'B')])
&gt;&gt;&gt; # Applying the do-operator will return a new DAG with the desired structure.
&gt;&gt;&gt; graph_do_A = graph.do('A')
&gt;&gt;&gt; # Which we can verify is missing the edges we would expect.
&gt;&gt;&gt; graph_do_A.edges
OutEdgeView([('A', 'B'), ('A', 'Y')])</p>
<p class="rubric">References</p>
<p>Causality: Models, Reasoning, and Inference, Judea Pearl (2000). p.70.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.get_ancestral_graph">
<span class="sig-name descname"><span class="pre">get_ancestral_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_ancestral_graph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.get_ancestral_graph" title="Permalink to this definition"></a></dt>
<dd><p>Returns the ancestral graph of the given <cite>nodes</cite>. The ancestral graph only
contains the nodes which are ancestors of atleast one of the variables in
node.
:param node: List of nodes whose ancestral graph needs to be computed.
:type node: iterable</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Ancestral Graph</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#coreBN.base.DAG" title="coreBN.base.DAG">coreBN.base.DAG</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">anc_dag</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">get_ancestral_graph</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">anc_dag</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">OutEdgeView([(&#39;D&#39;, &#39;A&#39;), (&#39;D&#39;, &#39;B&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.get_children">
<span class="sig-name descname"><span class="pre">get_children</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_children"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.get_children" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of children of node.
Throws an error if the node is not present in the graph.
:param node: The node whose children would be returned.
:type node: string, int or any hashable python object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">),</span>
<span class="go">                              (&#39;B&#39;, &#39;E&#39;), (&#39;B&#39;, &#39;F&#39;), (&#39;E&#39;, &#39;G&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">get_children</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="go">[&#39;D&#39;, &#39;E&#39;, &#39;F&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.get_immoralities">
<span class="sig-name descname"><span class="pre">get_immoralities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_immoralities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.get_immoralities" title="Permalink to this definition"></a></dt>
<dd><p>Finds all the immoralities in the model
A v-structure X -&gt; Z &lt;- Y is an immorality if there is no direct edge between X and Y .
:returns: <strong>Immoralities</strong> -- A set of all the immoralities in the model
:rtype: set</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span>
<span class="gp">... </span>                        <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;SAT&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;grade&#39;</span><span class="p">,</span> <span class="s1">&#39;letter&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">get_immoralities</span><span class="p">()</span>
<span class="go">{(&#39;diff&#39;, &#39;intel&#39;)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.get_independencies">
<span class="sig-name descname"><span class="pre">get_independencies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_independencies"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.get_independencies" title="Permalink to this definition"></a></dt>
<dd><p>Computes independencies in the DAG, by checking d-seperation.
:param latex: If latex=True then latex string of the independence assertion</p>
<blockquote>
<div><p>would be created.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>include_latents</strong> (<em>boolean</em>) -- If True, includes latent variables in the independencies. Otherwise,
only generates independencies on observed variables.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span><span class="o">.</span><span class="n">get_independencies</span><span class="p">()</span>
<span class="go">(X ⟂ Z | Y)</span>
<span class="go">(Z ⟂ X | Y)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.get_leaves">
<span class="sig-name descname"><span class="pre">get_leaves</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_leaves"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.get_leaves" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of leaves of the graph.
.. rubric:: Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()</span>
<span class="go">[&#39;C&#39;, &#39;D&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.get_markov_blanket">
<span class="sig-name descname"><span class="pre">get_markov_blanket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_markov_blanket"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.get_markov_blanket" title="Permalink to this definition"></a></dt>
<dd><p>Returns a markov blanket for a random variable. In the case
of Bayesian Networks, the markov blanket is the set of
node's parents, its children and its children's other parents.
:returns: <strong>Markov Blanket</strong> -- List of nodes in the markov blanket of <cite>node</cite>.
:rtype: list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<em>string</em><em>, </em><em>int</em><em> or </em><em>any hashable python object.</em>) -- The node whose markov blanket would be returned.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">TabularCPD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">),</span>
<span class="go">                       (&#39;s&#39;, &#39;v&#39;), (&#39;w&#39;, &#39;t&#39;), (&#39;w&#39;, &#39;m&#39;), (&#39;v&#39;, &#39;n&#39;), (&#39;v&#39;, &#39;q&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">get_markov_blanket</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="go">[&#39;s&#39;, &#39;w&#39;, &#39;x&#39;, &#39;u&#39;, &#39;z&#39;, &#39;v&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.get_parents">
<span class="sig-name descname"><span class="pre">get_parents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_parents"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.get_parents" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of parents of node.
Throws an error if the node is not present in the graph.
:param node: The node whose parents would be returned.
:type node: string, int or any hashable python object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">get_parents</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="s1">&#39;grade&#39;</span><span class="p">)</span>
<span class="go">[&#39;diff&#39;, &#39;intel&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.get_random">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_random</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_random"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.get_random" title="Permalink to this definition"></a></dt>
<dd><p>Returns a randomly generated DAG with <cite>n_nodes</cite> number of nodes with
edge probability being <cite>edge_prob</cite>.
:param n_nodes: The number of nodes in the randomly generated DAG.
:type n_nodes: int
:param edge_prob: The probability of edge between any two nodes in the topologically</p>
<blockquote>
<div><p>sorted DAG.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>latents</strong> (<em>bool</em><em> (</em><em>default: False</em><em>)</em>) -- If True, includes latent variables in the generated DAG.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Random DAG</strong> -- The randomly generated DAG.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#coreBN.base.DAG" title="coreBN.base.DAG">coreBN.base.DAG</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">get_random</span><span class="p">(</span><span class="n">n_nodes</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">edge_prob</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((0, 1, 2, 3, 4, 5, 6, 7, 8, 9))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_dag</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">OutEdgeView([(0, 6), (1, 6), (1, 7), (7, 9), (2, 5), (2, 7), (2, 8), (5, 9), (3, 7)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.get_roots">
<span class="sig-name descname"><span class="pre">get_roots</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_roots"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.get_roots" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of roots of the graph.
.. rubric:: Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span><span class="o">.</span><span class="n">get_roots</span><span class="p">()</span>
<span class="go">[&#39;A&#39;, &#39;E&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.in_degree_iter">
<span class="sig-name descname"><span class="pre">in_degree_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.in_degree_iter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.in_degree_iter" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.is_dconnected">
<span class="sig-name descname"><span class="pre">is_dconnected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.is_dconnected"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.is_dconnected" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if there is an active trail (i.e. d-connection) between
<cite>start</cite> and <cite>end</cite> node given that <cite>observed</cite> is observed.
:param start: The nodes in the DAG between which to check the d-connection/active trail.
:type start: int, str, any hashable python object.
:param end: The nodes in the DAG between which to check the d-connection/active trail.
:type end: int, str, any hashable python object.
:param observed: If given the active trail would be computed assuming these nodes to</p>
<blockquote>
<div><p>be observed.</p>
</div></blockquote>
<dl class="field-list simple">
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grades&#39;</span><span class="p">,</span> <span class="s1">&#39;letter&#39;</span><span class="p">,</span> <span class="s1">&#39;sat&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grades&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grades&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;grades&#39;</span><span class="p">,</span> <span class="s1">&#39;letter&#39;</span><span class="p">),</span>
<span class="gp">... </span>                        <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;sat&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">is_dconnected</span><span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;intel&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">is_dconnected</span><span class="p">(</span><span class="s1">&#39;grades&#39;</span><span class="p">,</span> <span class="s1">&#39;sat&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.is_iequivalent">
<span class="sig-name descname"><span class="pre">is_iequivalent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.is_iequivalent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.is_iequivalent" title="Permalink to this definition"></a></dt>
<dd><p>Checks whether the given model is I-equivalent
Two graphs G1 and G2 are said to be I-equivalent if they have same skeleton
and have same set of immoralities.
:param model:
:type model: A DAG object, for which you want to check I-equivalence</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>I-equivalence</strong> -- True if both are I-equivalent, False otherwise</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>boolean</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">),</span>
<span class="gp">... </span>                  <span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G1</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G1</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">is_iequivalent</span><span class="p">(</span><span class="n">G1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.local_independencies">
<span class="sig-name descname"><span class="pre">local_independencies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.local_independencies"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.local_independencies" title="Permalink to this definition"></a></dt>
<dd><p>Returns an instance of Independencies containing the local independencies
of each of the variables.
:param variables: variables whose local independencies are to be found.
:type variables: str or array like</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>                        <span class="p">(</span><span class="s1">&#39;grade&#39;</span><span class="p">,</span> <span class="s1">&#39;letter&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;SAT&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">student</span><span class="o">.</span><span class="n">local_independencies</span><span class="p">(</span><span class="s1">&#39;grade&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(grade ⟂ SAT | diff, intel)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.minimal_dseparator">
<span class="sig-name descname"><span class="pre">minimal_dseparator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.minimal_dseparator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.minimal_dseparator" title="Permalink to this definition"></a></dt>
<dd><p>Finds the minimal d-separating set for <cite>start</cite> and <cite>end</cite>.
:param start: The first node.
:type start: node
:param end: The second node.
:type end: node</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="o">.</span><span class="n">minimal_dseparator</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="go">{&#39;B&#39;}</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>[1] Algorithm 4, Page 10: Tian, Jin, Azaria Paz, and Judea Pearl. Finding minimal d-separators. Computer Science Department, University of California, 1998.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.moralize">
<span class="sig-name descname"><span class="pre">moralize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.moralize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.moralize" title="Permalink to this definition"></a></dt>
<dd><p>Removes all the immoralities in the DAG and creates a moral
graph (UndirectedGraph).
A v-structure X-&gt;Z&lt;-Y is an immorality if there is no directed edge
between X and Y.
.. rubric:: Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moral_graph</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">moralize</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moral_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">EdgeView([(&#39;intel&#39;, &#39;grade&#39;), (&#39;intel&#39;, &#39;diff&#39;), (&#39;grade&#39;, &#39;diff&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.out_degree_iter">
<span class="sig-name descname"><span class="pre">out_degree_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.out_degree_iter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.out_degree_iter" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.to_daft">
<span class="sig-name descname"><span class="pre">to_daft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'circular'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pgm_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.to_daft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.to_daft" title="Permalink to this definition"></a></dt>
<dd><p>Returns a daft (<a class="reference external" href="https://docs.daft-pgm.org/en/latest/">https://docs.daft-pgm.org/en/latest/</a>) object which can be rendered for
publication quality plots. The returned object's render method can be called to see the plots.
:param node_pos:</p>
<blockquote>
<div><dl class="simple">
<dt>If str: Must be one of the following: circular, kamada_kawai, planar, random, shell, sprint,</dt><dd><p>spectral, spiral. Please refer: <a class="reference external" href="https://networkx.org/documentation/stable//reference/drawing.html#module-networkx.drawing.layout">https://networkx.org/documentation/stable//reference/drawing.html#module-networkx.drawing.layout</a> for details on these layouts.</p>
</dd>
</dl>
<p>If dict should be of the form {node: (x coordinate, y coordinate)} describing the x and y coordinate of each
node.
If no argument is provided uses circular layout.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>latex</strong> (<em>boolean</em>) -- Whether to use latex for rendering the node names.</p></li>
<li><p><strong>pgm_params</strong> (<em>dict</em><em> (</em><em>optional</em><em>)</em>) -- Any additional parameters that need to be passed to <cite>daft.PGM</cite> initializer.
Should be of the form: {param_name: param_value}</p></li>
<li><p><strong>edge_params</strong> (<em>dict</em><em> (</em><em>optional</em><em>)</em>) -- Any additional edge parameters that need to be passed to <cite>daft.add_edge</cite> method.
Should be of the form: {(u1, v1): {param_name: param_value}, (u2, v2): {...} }</p></li>
<li><p><strong>node_params</strong> (<em>dict</em><em> (</em><em>optional</em><em>)</em>) -- Any additional node parameters that need to be passed to <cite>daft.add_node</cite> method.
Should be of the form: {node1: {param_name: param_value}, node2: {...} }</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Daft object</strong> -- Daft object for plotting the DAG.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>daft.PGM object</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="o">.</span><span class="n">to_daft</span><span class="p">(</span><span class="n">node_pos</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)})</span>
<span class="go">&lt;daft.PGM at 0x7fc756e936d0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="o">.</span><span class="n">to_daft</span><span class="p">(</span><span class="n">node_pos</span><span class="o">=</span><span class="s2">&quot;circular&quot;</span><span class="p">)</span>
<span class="go">&lt;daft.PGM at 0x7f9bb48c5eb0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="o">.</span><span class="n">to_daft</span><span class="p">(</span><span class="n">node_pos</span><span class="o">=</span><span class="s2">&quot;circular&quot;</span><span class="p">,</span> <span class="n">pgm_params</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;observed_style&#39;</span><span class="p">:</span> <span class="s1">&#39;inner&#39;</span><span class="p">})</span>
<span class="go">&lt;daft.PGM at 0x7f9bb48b0bb0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="o">.</span><span class="n">to_daft</span><span class="p">(</span><span class="n">node_pos</span><span class="o">=</span><span class="s2">&quot;circular&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">edge_params</span><span class="o">=</span><span class="p">{(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
<span class="gp">... </span>            <span class="n">node_params</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">}})</span>
<span class="go">&lt;daft.PGM at 0x7f9bb48b0bb0&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.DAG.to_pdag">
<span class="sig-name descname"><span class="pre">to_pdag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.to_pdag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.DAG.to_pdag" title="Permalink to this definition"></a></dt>
<dd><p>Returns the PDAG (the equivalence class of DAG; also known as CPDAG) of the DAG.
:returns: <strong>Partially oriented DAG</strong> -- An instance of coreBN.base.PDAG.
:rtype: coreBN.base.PDAG</p>
<p class="rubric">Examples</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.base.DAG.PDAG">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.base.DAG.</span></span><span class="sig-name descname"><span class="pre">PDAG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed_ebunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">undirected_ebunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#PDAG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.PDAG" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></p>
<p>Class for representing PDAGs (also known as CPDAG). PDAGs are the equivance classes of
DAGs and contain both directed and undirected edges.
Note: In this class, undirected edges are represented using two edges in both direction i.e.
an undirected edge between X - Y is represented using X -&gt; Y and X &lt;- Y.</p>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.PDAG.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#PDAG.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.PDAG.copy" title="Permalink to this definition"></a></dt>
<dd><p>Returns a copy of the object instance.
:returns: <strong>Copy of PDAG</strong> -- Returns a copy of self.
:rtype: coreBN.dag.PDAG</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.PDAG.to_dag">
<span class="sig-name descname"><span class="pre">to_dag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">required_edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#PDAG.to_dag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.PDAG.to_dag" title="Permalink to this definition"></a></dt>
<dd><p>Returns one possible DAG which is represented using the PDAG.
:param required_edges: The list of edges that should be included in the DAG.
:type required_edges: list, array-like of 2-tuples</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Returns an instance of DAG.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-coreBN.base.UndirectedGraph">
<span id="corebn-base-undirectedgraph-module"></span><h2>coreBN.base.UndirectedGraph module<a class="headerlink" href="#module-coreBN.base.UndirectedGraph" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="coreBN.base.UndirectedGraph.UndirectedGraph">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.base.UndirectedGraph.</span></span><span class="sig-name descname"><span class="pre">UndirectedGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ebunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/UndirectedGraph.html#UndirectedGraph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.UndirectedGraph.UndirectedGraph" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></p>
<p>Base class for all the Undirected Graphical models.
Each node in the graph can represent either a random variable, <cite>Factor</cite>,
or a cluster of random variables. Edges in the graph are interactions
between the nodes.
:param data: The data can be an edge list or any Networkx graph object.</p>
<blockquote>
<div><p>If data=None (default) an empty graph is created.</p>
</div></blockquote>
<dl class="field-list simple">
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.UndirectedGraph.UndirectedGraph.add_edge">
<span class="sig-name descname"><span class="pre">add_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/UndirectedGraph.html#UndirectedGraph.add_edge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.UndirectedGraph.UndirectedGraph.add_edge" title="Permalink to this definition"></a></dt>
<dd><p>Add an edge between u and v.
The nodes u and v will be automatically added if they are
not already in the graph.
:param u: Nodes can be any hashable Python object.
:type u: nodes
:param v: Nodes can be any hashable Python object.
:type v: nodes
:param weight: The weight of the edge.
:type weight: int, float (default=None)</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">UndirectedGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">UndirectedGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Charles&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="s1">&#39;Bob&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">EdgeView([(&#39;Alice&#39;, &#39;Bob&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.UndirectedGraph.UndirectedGraph.add_edges_from">
<span class="sig-name descname"><span class="pre">add_edges_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ebunch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/UndirectedGraph.html#UndirectedGraph.add_edges_from"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.UndirectedGraph.UndirectedGraph.add_edges_from" title="Permalink to this definition"></a></dt>
<dd><p>Add all the edges in edge_bunch.
If nodes referred in the ebunch are not already present, they
will be automatically added. Node names can be any hashable python
object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ebunch</strong> (<em>edge container</em>) -- Each edge given in the container will be added to the graph.
The edges must be given as 2-tuples (u, v).</p></li>
<li><p><strong>weights</strong> (<em>list</em><em>, </em><em>tuple</em><em> (</em><em>default=None</em><em>)</em>) -- A container of weights (int, float). The weight value at index i
is associated with the edge at index i.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">UndirectedGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">UndirectedGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Charles&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Charles&#39;</span><span class="p">)]</span>
<span class="go">&gt;&gt;&gt;#Adding edges with weights:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;Ankur&#39;</span><span class="p">,</span> <span class="s1">&#39;Maria&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Maria&#39;</span><span class="p">,</span> <span class="s1">&#39;Mason&#39;</span><span class="p">)],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;Ankur&#39;</span><span class="p">][</span><span class="s1">&#39;Maria&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.UndirectedGraph.UndirectedGraph.add_node">
<span class="sig-name descname"><span class="pre">add_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/UndirectedGraph.html#UndirectedGraph.add_node"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.UndirectedGraph.UndirectedGraph.add_node" title="Permalink to this definition"></a></dt>
<dd><p>Add a single node to the Graph.
:param node: The node to add to the graph.
:type node: str, int, or any hashable python object.
:param weight: The weight of the node.
:type weight: int, float</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">UndirectedGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">UndirectedGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((&#39;A&#39;,))</span>
<span class="go">Adding a node with some weight.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="go">The weight of these nodes can be accessed as:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.UndirectedGraph.UndirectedGraph.add_nodes_from">
<span class="sig-name descname"><span class="pre">add_nodes_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/UndirectedGraph.html#UndirectedGraph.add_nodes_from"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.UndirectedGraph.UndirectedGraph.add_nodes_from" title="Permalink to this definition"></a></dt>
<dd><p>Add multiple nodes to the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nodes</strong> (<em>iterable container</em>) -- A container of nodes (list, dict, set, or any hashable python
object).</p></li>
<li><p><strong>weights</strong> (<em>Adding nodes with</em>) -- A container of weights (int, float). The weight value at index i
is associated with the variable at index i.</p></li>
<li><p><strong>example</strong> (<em>Usage</em>) -- </p></li>
<li><p><strong>--------</strong> -- </p></li>
<li><p><strong>UndirectedGraph</strong> (<em>&gt;&gt;&gt; from coreBN.base import</em>) -- </p></li>
<li><p><strong>UndirectedGraph</strong><strong>(</strong><strong>)</strong> (<em>&gt;&gt;&gt; G =</em>) -- </p></li>
<li><p><strong>G.add_nodes_from</strong><strong>(</strong><strong>nodes=</strong><strong>[</strong><strong>'A'</strong> (<em>&gt;&gt;&gt;</em>) -- </p></li>
<li><p><strong>'B'</strong> -- </p></li>
<li><p><strong>'C'</strong><strong>]</strong><strong>)</strong> -- </p></li>
<li><p><strong>G.nodes</strong><strong>(</strong><strong>)</strong> (<em>&gt;&gt;&gt;</em>) -- </p></li>
<li><p><strong>NodeView</strong><strong>(</strong><strong>(</strong><strong>'A'</strong> -- </p></li>
<li><p><strong>'B'</strong> -- </p></li>
<li><p><strong>'C'</strong><strong>)</strong><strong>)</strong> -- </p></li>
<li><p><strong>weights</strong> -- </p></li>
<li><p><strong>G.add_nodes_from</strong><strong>(</strong><strong>nodes=</strong><strong>[</strong><strong>'D'</strong> (<em>&gt;&gt;&gt;</em>) -- </p></li>
<li><p><strong>'E'</strong><strong>]</strong> -- </p></li>
<li><p><strong>weights=</strong><strong>[</strong><strong>0.3</strong> -- </p></li>
<li><p><strong>0.6</strong><strong>]</strong><strong>)</strong> -- </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.UndirectedGraph.UndirectedGraph.is_clique">
<span class="sig-name descname"><span class="pre">is_clique</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/UndirectedGraph.html#UndirectedGraph.is_clique"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.UndirectedGraph.UndirectedGraph.is_clique" title="Permalink to this definition"></a></dt>
<dd><p>Check if the given nodes form a clique.
:param nodes: List of nodes to check if they are a part of any clique.
:type nodes: list, array-like</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">UndirectedGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">UndirectedGraph</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">),</span>
<span class="go">                                (&#39;B&#39;, &#39;E&#39;), (&#39;D&#39;, &#39;E&#39;), (&#39;E&#39;, &#39;F&#39;),</span>
<span class="go">                                (&#39;D&#39;, &#39;F&#39;), (&#39;B&#39;, &#39;F&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">is_clique</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">is_clique</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.UndirectedGraph.UndirectedGraph.is_triangulated">
<span class="sig-name descname"><span class="pre">is_triangulated</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/UndirectedGraph.html#UndirectedGraph.is_triangulated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.UndirectedGraph.UndirectedGraph.is_triangulated" title="Permalink to this definition"></a></dt>
<dd><p>Checks whether the undirected graph is triangulated (also known as chordal) or not.
A chordal graph is one in which all cycles of four or more vertices have a chord.
.. rubric:: Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">UndirectedGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">UndirectedGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="s1">&#39;x2&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="s1">&#39;x3&#39;</span><span class="p">),(</span><span class="s1">&#39;x2&#39;</span><span class="p">,</span> <span class="s1">&#39;x4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;x3&#39;</span><span class="p">,</span> <span class="s1">&#39;x4&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangulated</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="s1">&#39;x4&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangulated</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="module-coreBN.base">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-coreBN.base" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="coreBN.base.DAG">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.base.</span></span><span class="sig-name descname"><span class="pre">DAG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ebunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></p>
<p>Base class for all Directed Graphical Models.
Each node in the graph can represent either a random variable, <cite>Factor</cite>,
or a cluster of random variables. Edges in the graph represent the
dependencies between these.
:param data: Data to initialize graph. If data=None (default) an empty graph is</p>
<blockquote>
<div><p>created. The data can be an edge list or any Networkx graph object.</p>
</div></blockquote>
<dl class="field-list simple">
</dl>
<p class="rubric">Examples</p>
<p>Create an empty DAG with no nodes and no edges
&gt;&gt;&gt; from coreBN.base import DAG
&gt;&gt;&gt; G = DAG()
G can be grown in several ways:
<strong>Nodes:</strong>
Add one node at a time:
&gt;&gt;&gt; G.add_node(node='a')
Add the nodes from any container (a list, set or tuple or the nodes
from another graph).
&gt;&gt;&gt; G.add_nodes_from(nodes=['a', 'b'])
<strong>Edges:</strong>
G can also be grown by adding edges.
Add one edge,
&gt;&gt;&gt; G.add_edge(u='a', v='b')
a list of edges,
&gt;&gt;&gt; G.add_edges_from(ebunch=[('a', 'b'), ('b', 'c')])
If some edges connect nodes not yet in the model, the nodes
are added automatically. There are no errors when adding
nodes or edges that already exist.
<strong>Shortcuts:</strong>
Many common graph features allow python syntax for speed reporting.
&gt;&gt;&gt; 'a' in G     # check if node in graph
True
&gt;&gt;&gt; len(G)  # number of nodes in graph
3</p>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.active_trail_nodes">
<span class="sig-name descname"><span class="pre">active_trail_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.active_trail_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.active_trail_nodes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a dictionary with the given variables as keys and all the nodes reachable
from that respective variable as values.
:param variables: variables whose active trails are to be found.
:type variables: str or array like
:param observed: If given the active trails would be computed assuming these nodes to be</p>
<blockquote>
<div><p>observed.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>include_latents</strong> (<em>boolean</em><em> (</em><em>default: False</em><em>)</em>) -- Whether to include the latent variables in the returned active trail nodes.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grades&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grades&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grades&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">)</span>
<span class="go">{&#39;diff&#39;: {&#39;diff&#39;, &#39;grades&#39;}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">active_trail_nodes</span><span class="p">([</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;intel&#39;</span><span class="p">],</span> <span class="n">observed</span><span class="o">=</span><span class="s1">&#39;grades&#39;</span><span class="p">)</span>
<span class="go">{&#39;diff&#39;: {&#39;diff&#39;, &#39;intel&#39;}, &#39;intel&#39;: {&#39;diff&#39;, &#39;intel&#39;}}</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>Details of the algorithm can be found in 'Probabilistic Graphical Model
Principles and Techniques' - Koller and Friedman
Page 75 Algorithm 3.1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.add_edge">
<span class="sig-name descname"><span class="pre">add_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.add_edge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.add_edge" title="Permalink to this definition"></a></dt>
<dd><p>Add an edge between u and v.
The nodes u and v will be automatically added if they are
not already in the graph.
:param u: Nodes can be any hashable Python object.
:type u: nodes
:param v: Nodes can be any hashable Python object.
:type v: nodes
:param weight: The weight of the edge
:type weight: int, float (default=None)</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Charles&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="s1">&#39;Bob&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;)])</span>
<span class="go">When the node is not already present in the graph:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="s1">&#39;Ankur&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((&#39;Alice&#39;, &#39;Ankur&#39;, &#39;Bob&#39;, &#39;Charles&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;), (&#39;Alice&#39;, &#39;Ankur&#39;)])</span>
<span class="go">Adding edges with weight:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;Ankur&#39;</span><span class="p">,</span> <span class="s1">&#39;Maria&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;Ankur&#39;</span><span class="p">][</span><span class="s1">&#39;Maria&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.1}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.add_edges_from">
<span class="sig-name descname"><span class="pre">add_edges_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ebunch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.add_edges_from"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.add_edges_from" title="Permalink to this definition"></a></dt>
<dd><p>Add all the edges in ebunch.
If nodes referred in the ebunch are not already present, they
will be automatically added. Node names can be any hashable python
object.
<a href="#id5"><span class="problematic" id="id6">**</span></a>The behavior of adding weights is different than networkx.
:param ebunch: Each edge given in the container will be added to the graph.</p>
<blockquote>
<div><p>The edges must be given as 2-tuples (u, v).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>weights</strong> (<em>list</em><em>, </em><em>tuple</em><em> (</em><em>default=None</em><em>)</em>) -- A container of weights (int, float). The weight value at index i
is associated with the edge at index i.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Charles&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Charles&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;), (&#39;Bob&#39;, &#39;Charles&#39;)])</span>
<span class="go">When the node is not already in the model:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Ankur&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;, &#39;Ankur&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">OutEdgeView([(&#39;Alice&#39;, &#39;Bob&#39;), (&#39;Bob&#39;, &#39;Charles&#39;), (&#39;Alice&#39;, &#39;Ankur&#39;)])</span>
<span class="go">Adding edges with weights:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;Ankur&#39;</span><span class="p">,</span> <span class="s1">&#39;Maria&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Maria&#39;</span><span class="p">,</span> <span class="s1">&#39;Mason&#39;</span><span class="p">)],</span>
<span class="gp">... </span>                 <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;Ankur&#39;</span><span class="p">][</span><span class="s1">&#39;Maria&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;Maria&#39;</span><span class="p">][</span><span class="s1">&#39;Mason&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.5}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.add_node">
<span class="sig-name descname"><span class="pre">add_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.add_node"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.add_node" title="Permalink to this definition"></a></dt>
<dd><p>Adds a single node to the Graph.
:param node: The node to add to the graph.
:type node: str, int, or any hashable python object.
:param weight: The weight of the node.
:type weight: int, float
:param latent: Specifies whether the variable is latent or not.
:type latent: boolean (default: False)</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
<span class="go">[&#39;A&#39;]</span>
<span class="go">Adding a node with some weight.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="go">The weight of these nodes can be accessed as:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: None}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.add_nodes_from">
<span class="sig-name descname"><span class="pre">add_nodes_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.add_nodes_from"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.add_nodes_from" title="Permalink to this definition"></a></dt>
<dd><p>Add multiple nodes to the Graph.
<a href="#id7"><span class="problematic" id="id8">**</span></a>The behviour of adding weights is different than in networkx.
:param nodes: A container of nodes (list, dict, set, or any hashable python</p>
<blockquote>
<div><p>object).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>list</em><em>, </em><em>tuple</em><em> (</em><em>default=None</em><em>)</em>) -- A container of weights (int, float). The weight value at index i
is associated with the variable at index i.</p></li>
<li><p><strong>latent</strong> (<em>list</em><em>, </em><em>tuple</em><em> (</em><em>default=False</em><em>)</em>) -- A container of boolean. The value at index i tells whether the
node at index i is latent or not.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((&#39;A&#39;, &#39;B&#39;, &#39;C&#39;))</span>
<span class="go">Adding nodes with weights:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.6}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: None}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.do">
<span class="sig-name descname"><span class="pre">do</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.do"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.do" title="Permalink to this definition"></a></dt>
<dd><p>Applies the do operator to the graph and returns a new DAG with the
transformed graph.
The do-operator, do(X = x) has the effect of removing all edges from
the parents of X and setting X to the given value x.
:param nodes: The names of the nodes to apply the do-operator for.
:type nodes: list, array-like
:param inplace: If inplace=True, makes the changes to the current object,</p>
<blockquote>
<div><p>otherwise returns a new instance.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Modified DAG</strong> -- A new instance of DAG modified by the do-operator</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#coreBN.base.DAG" title="coreBN.base.DAG">coreBN.base.DAG</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Initialize a DAG
&gt;&gt;&gt; graph = DAG()
&gt;&gt;&gt; graph.add_edges_from([('X', 'A'),
...                       ('A', 'Y'),
...                       ('A', 'B')])
&gt;&gt;&gt; # Applying the do-operator will return a new DAG with the desired structure.
&gt;&gt;&gt; graph_do_A = graph.do('A')
&gt;&gt;&gt; # Which we can verify is missing the edges we would expect.
&gt;&gt;&gt; graph_do_A.edges
OutEdgeView([('A', 'B'), ('A', 'Y')])</p>
<p class="rubric">References</p>
<p>Causality: Models, Reasoning, and Inference, Judea Pearl (2000). p.70.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.get_ancestral_graph">
<span class="sig-name descname"><span class="pre">get_ancestral_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_ancestral_graph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.get_ancestral_graph" title="Permalink to this definition"></a></dt>
<dd><p>Returns the ancestral graph of the given <cite>nodes</cite>. The ancestral graph only
contains the nodes which are ancestors of atleast one of the variables in
node.
:param node: List of nodes whose ancestral graph needs to be computed.
:type node: iterable</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Ancestral Graph</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#coreBN.base.DAG" title="coreBN.base.DAG">coreBN.base.DAG</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">anc_dag</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">get_ancestral_graph</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">anc_dag</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">OutEdgeView([(&#39;D&#39;, &#39;A&#39;), (&#39;D&#39;, &#39;B&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.get_children">
<span class="sig-name descname"><span class="pre">get_children</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_children"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.get_children" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of children of node.
Throws an error if the node is not present in the graph.
:param node: The node whose children would be returned.
:type node: string, int or any hashable python object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">),</span>
<span class="go">                              (&#39;B&#39;, &#39;E&#39;), (&#39;B&#39;, &#39;F&#39;), (&#39;E&#39;, &#39;G&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">get_children</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="go">[&#39;D&#39;, &#39;E&#39;, &#39;F&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.get_immoralities">
<span class="sig-name descname"><span class="pre">get_immoralities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_immoralities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.get_immoralities" title="Permalink to this definition"></a></dt>
<dd><p>Finds all the immoralities in the model
A v-structure X -&gt; Z &lt;- Y is an immorality if there is no direct edge between X and Y .
:returns: <strong>Immoralities</strong> -- A set of all the immoralities in the model
:rtype: set</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span>
<span class="gp">... </span>                        <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;SAT&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;grade&#39;</span><span class="p">,</span> <span class="s1">&#39;letter&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">get_immoralities</span><span class="p">()</span>
<span class="go">{(&#39;diff&#39;, &#39;intel&#39;)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.get_independencies">
<span class="sig-name descname"><span class="pre">get_independencies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_independencies"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.get_independencies" title="Permalink to this definition"></a></dt>
<dd><p>Computes independencies in the DAG, by checking d-seperation.
:param latex: If latex=True then latex string of the independence assertion</p>
<blockquote>
<div><p>would be created.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>include_latents</strong> (<em>boolean</em>) -- If True, includes latent variables in the independencies. Otherwise,
only generates independencies on observed variables.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span><span class="o">.</span><span class="n">get_independencies</span><span class="p">()</span>
<span class="go">(X ⟂ Z | Y)</span>
<span class="go">(Z ⟂ X | Y)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.get_leaves">
<span class="sig-name descname"><span class="pre">get_leaves</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_leaves"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.get_leaves" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of leaves of the graph.
.. rubric:: Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()</span>
<span class="go">[&#39;C&#39;, &#39;D&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.get_markov_blanket">
<span class="sig-name descname"><span class="pre">get_markov_blanket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_markov_blanket"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.get_markov_blanket" title="Permalink to this definition"></a></dt>
<dd><p>Returns a markov blanket for a random variable. In the case
of Bayesian Networks, the markov blanket is the set of
node's parents, its children and its children's other parents.
:returns: <strong>Markov Blanket</strong> -- List of nodes in the markov blanket of <cite>node</cite>.
:rtype: list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<em>string</em><em>, </em><em>int</em><em> or </em><em>any hashable python object.</em>) -- The node whose markov blanket would be returned.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.factors.discrete</span> <span class="kn">import</span> <span class="n">TabularCPD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">),</span>
<span class="go">                       (&#39;s&#39;, &#39;v&#39;), (&#39;w&#39;, &#39;t&#39;), (&#39;w&#39;, &#39;m&#39;), (&#39;v&#39;, &#39;n&#39;), (&#39;v&#39;, &#39;q&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">get_markov_blanket</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="go">[&#39;s&#39;, &#39;w&#39;, &#39;x&#39;, &#39;u&#39;, &#39;z&#39;, &#39;v&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.get_parents">
<span class="sig-name descname"><span class="pre">get_parents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_parents"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.get_parents" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of parents of node.
Throws an error if the node is not present in the graph.
:param node: The node whose parents would be returned.
:type node: string, int or any hashable python object.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">get_parents</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="s1">&#39;grade&#39;</span><span class="p">)</span>
<span class="go">[&#39;diff&#39;, &#39;intel&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.get_random">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_random</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_random"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.get_random" title="Permalink to this definition"></a></dt>
<dd><p>Returns a randomly generated DAG with <cite>n_nodes</cite> number of nodes with
edge probability being <cite>edge_prob</cite>.
:param n_nodes: The number of nodes in the randomly generated DAG.
:type n_nodes: int
:param edge_prob: The probability of edge between any two nodes in the topologically</p>
<blockquote>
<div><p>sorted DAG.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>latents</strong> (<em>bool</em><em> (</em><em>default: False</em><em>)</em>) -- If True, includes latent variables in the generated DAG.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Random DAG</strong> -- The randomly generated DAG.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#coreBN.base.DAG" title="coreBN.base.DAG">coreBN.base.DAG</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">get_random</span><span class="p">(</span><span class="n">n_nodes</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">edge_prob</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((0, 1, 2, 3, 4, 5, 6, 7, 8, 9))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_dag</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">OutEdgeView([(0, 6), (1, 6), (1, 7), (7, 9), (2, 5), (2, 7), (2, 8), (5, 9), (3, 7)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.get_roots">
<span class="sig-name descname"><span class="pre">get_roots</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.get_roots"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.get_roots" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of roots of the graph.
.. rubric:: Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span><span class="o">.</span><span class="n">get_roots</span><span class="p">()</span>
<span class="go">[&#39;A&#39;, &#39;E&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.in_degree_iter">
<span class="sig-name descname"><span class="pre">in_degree_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.in_degree_iter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.in_degree_iter" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.is_dconnected">
<span class="sig-name descname"><span class="pre">is_dconnected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.is_dconnected"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.is_dconnected" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if there is an active trail (i.e. d-connection) between
<cite>start</cite> and <cite>end</cite> node given that <cite>observed</cite> is observed.
:param start: The nodes in the DAG between which to check the d-connection/active trail.
:type start: int, str, any hashable python object.
:param end: The nodes in the DAG between which to check the d-connection/active trail.
:type end: int, str, any hashable python object.
:param observed: If given the active trail would be computed assuming these nodes to</p>
<blockquote>
<div><p>be observed.</p>
</div></blockquote>
<dl class="field-list simple">
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grades&#39;</span><span class="p">,</span> <span class="s1">&#39;letter&#39;</span><span class="p">,</span> <span class="s1">&#39;sat&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grades&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grades&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;grades&#39;</span><span class="p">,</span> <span class="s1">&#39;letter&#39;</span><span class="p">),</span>
<span class="gp">... </span>                        <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;sat&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">is_dconnected</span><span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;intel&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">is_dconnected</span><span class="p">(</span><span class="s1">&#39;grades&#39;</span><span class="p">,</span> <span class="s1">&#39;sat&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.is_iequivalent">
<span class="sig-name descname"><span class="pre">is_iequivalent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.is_iequivalent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.is_iequivalent" title="Permalink to this definition"></a></dt>
<dd><p>Checks whether the given model is I-equivalent
Two graphs G1 and G2 are said to be I-equivalent if they have same skeleton
and have same set of immoralities.
:param model:
:type model: A DAG object, for which you want to check I-equivalence</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>I-equivalence</strong> -- True if both are I-equivalent, False otherwise</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>boolean</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">),</span>
<span class="gp">... </span>                  <span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G1</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G1</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">is_iequivalent</span><span class="p">(</span><span class="n">G1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.local_independencies">
<span class="sig-name descname"><span class="pre">local_independencies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.local_independencies"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.local_independencies" title="Permalink to this definition"></a></dt>
<dd><p>Returns an instance of Independencies containing the local independencies
of each of the variables.
:param variables: variables whose local independencies are to be found.
:type variables: str or array like</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">student</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>                        <span class="p">(</span><span class="s1">&#39;grade&#39;</span><span class="p">,</span> <span class="s1">&#39;letter&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;SAT&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">student</span><span class="o">.</span><span class="n">local_independencies</span><span class="p">(</span><span class="s1">&#39;grade&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(grade ⟂ SAT | diff, intel)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.minimal_dseparator">
<span class="sig-name descname"><span class="pre">minimal_dseparator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.minimal_dseparator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.minimal_dseparator" title="Permalink to this definition"></a></dt>
<dd><p>Finds the minimal d-separating set for <cite>start</cite> and <cite>end</cite>.
:param start: The first node.
:type start: node
:param end: The second node.
:type end: node</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="o">.</span><span class="n">minimal_dseparator</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="go">{&#39;B&#39;}</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>[1] Algorithm 4, Page 10: Tian, Jin, Azaria Paz, and Judea Pearl. Finding minimal d-separators. Computer Science Department, University of California, 1998.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.moralize">
<span class="sig-name descname"><span class="pre">moralize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.moralize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.moralize" title="Permalink to this definition"></a></dt>
<dd><p>Removes all the immoralities in the DAG and creates a moral
graph (UndirectedGraph).
A v-structure X-&gt;Z&lt;-Y is an immorality if there is no directed edge
between X and Y.
.. rubric:: Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;intel&#39;</span><span class="p">,</span> <span class="s1">&#39;grade&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moral_graph</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">moralize</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moral_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">EdgeView([(&#39;intel&#39;, &#39;grade&#39;), (&#39;intel&#39;, &#39;diff&#39;), (&#39;grade&#39;, &#39;diff&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.out_degree_iter">
<span class="sig-name descname"><span class="pre">out_degree_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.out_degree_iter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.out_degree_iter" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.to_daft">
<span class="sig-name descname"><span class="pre">to_daft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'circular'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pgm_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.to_daft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.to_daft" title="Permalink to this definition"></a></dt>
<dd><p>Returns a daft (<a class="reference external" href="https://docs.daft-pgm.org/en/latest/">https://docs.daft-pgm.org/en/latest/</a>) object which can be rendered for
publication quality plots. The returned object's render method can be called to see the plots.
:param node_pos:</p>
<blockquote>
<div><dl class="simple">
<dt>If str: Must be one of the following: circular, kamada_kawai, planar, random, shell, sprint,</dt><dd><p>spectral, spiral. Please refer: <a class="reference external" href="https://networkx.org/documentation/stable//reference/drawing.html#module-networkx.drawing.layout">https://networkx.org/documentation/stable//reference/drawing.html#module-networkx.drawing.layout</a> for details on these layouts.</p>
</dd>
</dl>
<p>If dict should be of the form {node: (x coordinate, y coordinate)} describing the x and y coordinate of each
node.
If no argument is provided uses circular layout.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>latex</strong> (<em>boolean</em>) -- Whether to use latex for rendering the node names.</p></li>
<li><p><strong>pgm_params</strong> (<em>dict</em><em> (</em><em>optional</em><em>)</em>) -- Any additional parameters that need to be passed to <cite>daft.PGM</cite> initializer.
Should be of the form: {param_name: param_value}</p></li>
<li><p><strong>edge_params</strong> (<em>dict</em><em> (</em><em>optional</em><em>)</em>) -- Any additional edge parameters that need to be passed to <cite>daft.add_edge</cite> method.
Should be of the form: {(u1, v1): {param_name: param_value}, (u2, v2): {...} }</p></li>
<li><p><strong>node_params</strong> (<em>dict</em><em> (</em><em>optional</em><em>)</em>) -- Any additional node parameters that need to be passed to <cite>daft.add_node</cite> method.
Should be of the form: {node1: {param_name: param_value}, node2: {...} }</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Daft object</strong> -- Daft object for plotting the DAG.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>daft.PGM object</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="o">.</span><span class="n">to_daft</span><span class="p">(</span><span class="n">node_pos</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)})</span>
<span class="go">&lt;daft.PGM at 0x7fc756e936d0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="o">.</span><span class="n">to_daft</span><span class="p">(</span><span class="n">node_pos</span><span class="o">=</span><span class="s2">&quot;circular&quot;</span><span class="p">)</span>
<span class="go">&lt;daft.PGM at 0x7f9bb48c5eb0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="o">.</span><span class="n">to_daft</span><span class="p">(</span><span class="n">node_pos</span><span class="o">=</span><span class="s2">&quot;circular&quot;</span><span class="p">,</span> <span class="n">pgm_params</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;observed_style&#39;</span><span class="p">:</span> <span class="s1">&#39;inner&#39;</span><span class="p">})</span>
<span class="go">&lt;daft.PGM at 0x7f9bb48b0bb0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="o">.</span><span class="n">to_daft</span><span class="p">(</span><span class="n">node_pos</span><span class="o">=</span><span class="s2">&quot;circular&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">edge_params</span><span class="o">=</span><span class="p">{(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}},</span>
<span class="gp">... </span>            <span class="n">node_params</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="s1">&#39;rectangle&#39;</span><span class="p">}})</span>
<span class="go">&lt;daft.PGM at 0x7f9bb48b0bb0&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.DAG.to_pdag">
<span class="sig-name descname"><span class="pre">to_pdag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#DAG.to_pdag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.DAG.to_pdag" title="Permalink to this definition"></a></dt>
<dd><p>Returns the PDAG (the equivalence class of DAG; also known as CPDAG) of the DAG.
:returns: <strong>Partially oriented DAG</strong> -- An instance of coreBN.base.PDAG.
:rtype: coreBN.base.PDAG</p>
<p class="rubric">Examples</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.base.PDAG">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.base.</span></span><span class="sig-name descname"><span class="pre">PDAG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed_ebunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">undirected_ebunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#PDAG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.PDAG" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraph</span></code></p>
<p>Class for representing PDAGs (also known as CPDAG). PDAGs are the equivance classes of
DAGs and contain both directed and undirected edges.
Note: In this class, undirected edges are represented using two edges in both direction i.e.
an undirected edge between X - Y is represented using X -&gt; Y and X &lt;- Y.</p>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.PDAG.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#PDAG.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.PDAG.copy" title="Permalink to this definition"></a></dt>
<dd><p>Returns a copy of the object instance.
:returns: <strong>Copy of PDAG</strong> -- Returns a copy of self.
:rtype: coreBN.dag.PDAG</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.PDAG.to_dag">
<span class="sig-name descname"><span class="pre">to_dag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">required_edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/DAG.html#PDAG.to_dag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.PDAG.to_dag" title="Permalink to this definition"></a></dt>
<dd><p>Returns one possible DAG which is represented using the PDAG.
:param required_edges: The list of edges that should be included in the DAG.
:type required_edges: list, array-like of 2-tuples</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Returns an instance of DAG.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="coreBN.base.UndirectedGraph">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">coreBN.base.</span></span><span class="sig-name descname"><span class="pre">UndirectedGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ebunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/UndirectedGraph.html#UndirectedGraph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.UndirectedGraph" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></p>
<p>Base class for all the Undirected Graphical models.
Each node in the graph can represent either a random variable, <cite>Factor</cite>,
or a cluster of random variables. Edges in the graph are interactions
between the nodes.
:param data: The data can be an edge list or any Networkx graph object.</p>
<blockquote>
<div><p>If data=None (default) an empty graph is created.</p>
</div></blockquote>
<dl class="field-list simple">
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.UndirectedGraph.add_edge">
<span class="sig-name descname"><span class="pre">add_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/UndirectedGraph.html#UndirectedGraph.add_edge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.UndirectedGraph.add_edge" title="Permalink to this definition"></a></dt>
<dd><p>Add an edge between u and v.
The nodes u and v will be automatically added if they are
not already in the graph.
:param u: Nodes can be any hashable Python object.
:type u: nodes
:param v: Nodes can be any hashable Python object.
:type v: nodes
:param weight: The weight of the edge.
:type weight: int, float (default=None)</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">UndirectedGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">UndirectedGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Charles&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="s1">&#39;Bob&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charles&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">EdgeView([(&#39;Alice&#39;, &#39;Bob&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.UndirectedGraph.add_edges_from">
<span class="sig-name descname"><span class="pre">add_edges_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ebunch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/UndirectedGraph.html#UndirectedGraph.add_edges_from"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.UndirectedGraph.add_edges_from" title="Permalink to this definition"></a></dt>
<dd><p>Add all the edges in edge_bunch.
If nodes referred in the ebunch are not already present, they
will be automatically added. Node names can be any hashable python
object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ebunch</strong> (<em>edge container</em>) -- Each edge given in the container will be added to the graph.
The edges must be given as 2-tuples (u, v).</p></li>
<li><p><strong>weights</strong> (<em>list</em><em>, </em><em>tuple</em><em> (</em><em>default=None</em><em>)</em>) -- A container of weights (int, float). The weight value at index i
is associated with the edge at index i.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">UndirectedGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">UndirectedGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Charles&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Charles&#39;</span><span class="p">)]</span>
<span class="go">&gt;&gt;&gt;#Adding edges with weights:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="s1">&#39;Ankur&#39;</span><span class="p">,</span> <span class="s1">&#39;Maria&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Maria&#39;</span><span class="p">,</span> <span class="s1">&#39;Mason&#39;</span><span class="p">)],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;Ankur&#39;</span><span class="p">][</span><span class="s1">&#39;Maria&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.UndirectedGraph.add_node">
<span class="sig-name descname"><span class="pre">add_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/UndirectedGraph.html#UndirectedGraph.add_node"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.UndirectedGraph.add_node" title="Permalink to this definition"></a></dt>
<dd><p>Add a single node to the Graph.
:param node: The node to add to the graph.
:type node: str, int, or any hashable python object.
:param weight: The weight of the node.
:type weight: int, float</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">UndirectedGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">UndirectedGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="go">NodeView((&#39;A&#39;,))</span>
<span class="go">Adding a node with some weight.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="go">The weight of these nodes can be accessed as:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span>
<span class="go">{&#39;weight&#39;: 0.3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.UndirectedGraph.add_nodes_from">
<span class="sig-name descname"><span class="pre">add_nodes_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/UndirectedGraph.html#UndirectedGraph.add_nodes_from"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.UndirectedGraph.add_nodes_from" title="Permalink to this definition"></a></dt>
<dd><p>Add multiple nodes to the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nodes</strong> (<em>iterable container</em>) -- A container of nodes (list, dict, set, or any hashable python
object).</p></li>
<li><p><strong>weights</strong> (<em>Adding nodes with</em>) -- A container of weights (int, float). The weight value at index i
is associated with the variable at index i.</p></li>
<li><p><strong>example</strong> (<em>Usage</em>) -- </p></li>
<li><p><strong>--------</strong> -- </p></li>
<li><p><strong>UndirectedGraph</strong> (<em>&gt;&gt;&gt; from coreBN.base import</em>) -- </p></li>
<li><p><strong>UndirectedGraph</strong><strong>(</strong><strong>)</strong> (<em>&gt;&gt;&gt; G =</em>) -- </p></li>
<li><p><strong>G.add_nodes_from</strong><strong>(</strong><strong>nodes=</strong><strong>[</strong><strong>'A'</strong> (<em>&gt;&gt;&gt;</em>) -- </p></li>
<li><p><strong>'B'</strong> -- </p></li>
<li><p><strong>'C'</strong><strong>]</strong><strong>)</strong> -- </p></li>
<li><p><strong>G.nodes</strong><strong>(</strong><strong>)</strong> (<em>&gt;&gt;&gt;</em>) -- </p></li>
<li><p><strong>NodeView</strong><strong>(</strong><strong>(</strong><strong>'A'</strong> -- </p></li>
<li><p><strong>'B'</strong> -- </p></li>
<li><p><strong>'C'</strong><strong>)</strong><strong>)</strong> -- </p></li>
<li><p><strong>weights</strong> -- </p></li>
<li><p><strong>G.add_nodes_from</strong><strong>(</strong><strong>nodes=</strong><strong>[</strong><strong>'D'</strong> (<em>&gt;&gt;&gt;</em>) -- </p></li>
<li><p><strong>'E'</strong><strong>]</strong> -- </p></li>
<li><p><strong>weights=</strong><strong>[</strong><strong>0.3</strong> -- </p></li>
<li><p><strong>0.6</strong><strong>]</strong><strong>)</strong> -- </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.UndirectedGraph.is_clique">
<span class="sig-name descname"><span class="pre">is_clique</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/UndirectedGraph.html#UndirectedGraph.is_clique"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.UndirectedGraph.is_clique" title="Permalink to this definition"></a></dt>
<dd><p>Check if the given nodes form a clique.
:param nodes: List of nodes to check if they are a part of any clique.
:type nodes: list, array-like</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">UndirectedGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">UndirectedGraph</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">),</span>
<span class="go">                                (&#39;B&#39;, &#39;E&#39;), (&#39;D&#39;, &#39;E&#39;), (&#39;E&#39;, &#39;F&#39;),</span>
<span class="go">                                (&#39;D&#39;, &#39;F&#39;), (&#39;B&#39;, &#39;F&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">is_clique</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">is_clique</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coreBN.base.UndirectedGraph.is_triangulated">
<span class="sig-name descname"><span class="pre">is_triangulated</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coreBN/base/UndirectedGraph.html#UndirectedGraph.is_triangulated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#coreBN.base.UndirectedGraph.is_triangulated" title="Permalink to this definition"></a></dt>
<dd><p>Checks whether the undirected graph is triangulated (also known as chordal) or not.
A chordal graph is one in which all cycles of four or more vertices have a chord.
.. rubric:: Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">coreBN.base</span> <span class="kn">import</span> <span class="n">UndirectedGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">UndirectedGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="s1">&#39;x2&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="s1">&#39;x3&#39;</span><span class="p">),(</span><span class="s1">&#39;x2&#39;</span><span class="p">,</span> <span class="s1">&#39;x4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;x3&#39;</span><span class="p">,</span> <span class="s1">&#39;x4&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangulated</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="s1">&#39;x4&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">is_triangulated</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="coreBN.IO.html" class="btn btn-neutral float-left" title="coreBN.IO package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="coreBN.estimators.html" class="btn btn-neutral float-right" title="coreBN.estimators package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Serafina Di Gioia.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>